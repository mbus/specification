\svnInfo $Id$

\section{Requirements \& Design Considerations}
\label{sec:requirements}
\label{sec:design}
This section attempts to explain the design tradeoffs made in the \bus design.

\paragraph{Define bus PHY, MAC and application logic interface}
We take a vertical integration approach, controlling more of the complete
stack in an effort to obtain every available ounce of energy efficiency within
our further design constraints.

\paragraph{Must be fully-synthesizable}
In an effort to make \bus ubiquitous, it is important that other designers can
easily add \bus to their systems/chips. In practice, this means a
fully-synthesizable design, such that simple, pure verilog can be given to any
individual wishing to implement \bus. The provides added advantages in
pre-silicon testing and validation. One thought was using both {\tt CLK} edges
to alternate {\sc drive} and {\sc latch} states to reduce the power draws by
{\tt CLK} wire. However, using both edges requires a custom designed flip-flop
which is not supported by commom standard cell library. Using single edge 
trigger has worse energy-per-bit but retains better portability.

\paragraph{Optimize for synthesis simplicity over speed}
The synthesizability is paramount. While it is possible to build hardware the
latches on both the rising and falling clock edge, it is harder to design this
in Verilog. When faced with such tradeoffs, efficiency loses to simplicity /
synthesizability.

\paragraph{Must be low-power}
The \bus was designed for the Michigan Micro Mote~(M3) project. The system is
designed to run off a 0.5~$\mu$Ah battery. To serve as a feasible
communication bus, the energy consumption must be on the order of $pW$. XXX:
Ballpark expected transaction sizes, frequency, etc -- actual energy budget.

\paragraph{Support Multi-master operation / bus arbitration / avoid race
conditions}
As every layer is capable of entering an extreme low-power state, any layer
must be capable of waking the system. The waking layer must also be capable of
communicating (i) who woke the system and (ii) why. While such a system could
query (ii) given (i), determining who woke the system requires a complex
dedicated controller, or for the waking layer to simply announce it. A
multi-master bus greatly simplifies the software design and allows for things
such as DMA from an imager chip to a radio chip, without necessarily requiring
CPU intervention.

Once multi-master is agreed upon, some form of arbitration scheme must be
devised, as well as consideration for races as multiple layers attempt to
acquire the bus.

\paragraph{Minimize pins}
\paragraph{Minimize gates}
\paragraph{Limit to four I/O pads}
The physical area of the M3 system is extremely constrained. There is only
room for four I/O {\em pads} on each layer of the system (keep in mind that
forming a net/bus still requires two {\em pads} when wirebonding).

\paragraph{Minimize timing uncertainty/latency/jitter}

\paragraph{Allow for wakeup that takes time}
As the system supports extremely low-power sleep, the bus must tolerate /
account for a lag in waking layers of the system up. In practice this is
mostly a focus on the bus layer controller for each layer at first, followed
by layer-specific concerns of how much local buffer should be necessary and
when/how to wake the proper layer.

\paragraph{Active vs sleep mode; want backward compatibility}
The bus needs an idle state that consumes very little power. Ideally, each
layer not participating in the current transaction also burns very little
power.

There should also be some consideration for future-proof design, that is the
introduction of a newer protocol that can run on the bus that older
controllers can silently ignore.

\paragraph{Ensure that bus reset is possible}
Stuff happens. It is important that there exists some kind of escape hatch to
rescue / reset the bus.

\paragraph{Support variable-length packet sizes}
Short packet length limits (e.g. order 4~bytes) lead to unacceptably high
protocol overheads for large (order 1~kB+) messages. An upper bound on
packet-length leads to possibly complex software-level fragmentation schemes
(or worse hardware-level if the bus packet length $<$ message buffer).

A leading length field with a reasonably large upper bound would then be
acceptable, although not ideal. The goal is to allow for true arbitrary length
packets if possible.

\paragraph{Consider automatic address space management protocol?}
There is an extensibility / simplicity trade-off. I2C only allowed for 128
addresses, which for an individual bus instance was seen as more than enough
(still pretty true with the loading requirements, but repeaters / extenders
make that less true). The real issue though is address space collisions
between generic components. To build a plug 'n play bus of any arbitrary
pieces requires the whole corpus of parts to have non-conflicting addresses.
This motivates extensibility.

Addressing has not yet been defined. It would be interesting to do the math
and see what percentage of addresses a lost to a scheme such as `no legal
address ends in 00', allowing easy, endless extensibility, but at XX\% cost?

\paragraph{Allow interposing of the bus to read out / insert data from
external source}
Sniffing pretty much any bus design is easy, but adding devices post-hoc is a
harder requirement. There is great motivation for transient connection of
devices (programmer, debugger, etc), and also some motivation for the ability
to permanently add new devices to an existing bus.

A reasonable argument for the permanent addition is that the addition /
removal is so infrequent that it can be an intrusive process; unless something
like a pre-packaged IC had a \bus internally and there was desire to allow the
possible addition of external components? In that case though, why not simply
use a separate bus, or leverage the same mechanism as...

Transient additions to the bus are much less negotiable. It's not immediately
obvious if there are examples beyond a programmer / debugger, but those two
are sufficiently critical as to motivate the need for some kind of external
transient device.

\paragraph{Must be uni-directional}
Bi-Directional analog hardware is complex and not synthesizable.

\paragraph{Endianness}
\subparagraph{Byte-Level}
No specific design consideration here per se. Given that \bus supports
messages of an arbitrary length, it simply felt more logical to send bytes
from 0{\ldots}N instead of N{\ldots}0.
\subparagraph{Bit-Level}
Again an arbitrary decision. The first test implementation elected to use MSB
and the decision was made.

\paragraph{Retransmission}
Hardware retransmission carries risks of accidentally locking up the bus,
endlessly retransmitting. While ideas such as a maximum retry count (SMBus)
mitigate this, the added complexity and risk of a hardware retransmission tip
the scales in favor of pushing the retransmission decisions to software.

To provide the software layer with more information, we choose to require the
indication of the number of bytes actually transmitted. While transient faults
could certainly occur, it is reasonable that the software can infer different
{\em probable} causes from the amount of the message that was transmitted.

\paragraph{Flow Control}
Any form of flow control requires communication {\em mid-transmission} between
the transmitting and receiving node. This could be accomplished by
periodically (e.g. every word) switching roles, but this introduces a large
amount of complexity. Another solution is an open-collector style bus (e.g.
I2C), but such designs were ruled out previously for power and
synthesizability considerations.

Our resulting selection trades simplicity for efficiency w.r.t.\ flow control.
If a receiving node's RX buffer is overrun, it may (but is not required to)
issue a Bus~Reset. Otherwise an entire message must be transmitted before any
indication of failure or success is indicated.

In practice, transmitting nodes should consider sending some form of {\em
ping} message to a destination node to validate its presence before sending a
large transmission to minimize waste if the destination node is not actually
present. \bus is not designed for a changing topology, as such discovery of
this nature need only be performed once and the amortized cost is considered
negligible.

\paragraph{Acknowledgement granularity}
As \bus supports messages of arbitrary length, a natural question arises for
the granularity of acknowledgements. At one extreme, designs such as I2C elect
to acknowledge every byte. \bus takes the opposite approach, providing only a
single acknowledgement at the end of a transmission in an all-or-nothing
fashion. The rationale for this decision again returns to simplicity and
efficiency in design. While a receiver-driven acknowledgement cycle could
easily be added every \nth{33} bit, the relative merits of this are not great.
Assuming a receiver exists on the bus, by not electing to issue a Bus~Rest, a
receiver implicitly ACKs every bit sent. A receiver that has occasion to NAK a
transmission may do so at any time during transmission. Transient faults, e.g.
a missed clock edge, will cause the node to fall into reset
(see~\ref{sec:design-reset}), in which case the message will not be ACK'd---a
single data-bit error would require a node to miss four consecutive clock
edges, which is considered extremely unlikely. The remaining consideration
then is the absent receiver, which is a relative non-issue for a bus such as
\bus with a static topology.

\paragraph{Streaming}
Some bus designs incorporate a ``streaming'' mode, which allows for a series
of physical bus transactions to be considered one continguous message at the
receiving layer. As \bus allows for arbitrary length messages, such a feature
becomes largely unnecessary, and \bus defines no streaming primative.

\paragraph{Avoid ratioed-logic, avoid timing constraints}

\paragraph{Idle State Should Be High}
We probably don't have to mention this, but it's important that they are high
since we can pull down a node with minimum power consumption (vs pulling a
node high). When a node pulls low, the pmu is still in standby mode so,
there's not much power.  I'm not sure if we want to get into the power budgets
of the nodes in different modes - it will depend on the pmu design...

\paragraph{Consider Arbitration as DOUT and CLK low?}
One more note on this time:  currently, the spec requires that the pmu resides
with the ctr processor, since it's the only node that is definitely aware of a
wakeup.  However, if the ctr instead pulls down right way on clk (not data),
which does not take much power, then all nodes will know that a bus request
has been detected and the pmu can reside on any node.  The ctr that would have
to delay before raising the clk to allow the pmu to switch mode etc...

\subsection{Reset Design}
\label{sec:design-reset}
The reset mechanism is the \bus escape hatch. Its reliability is a first
order design constraint, and here we attempt to demonstrate how the reset
mechanism can in all possible states reliably reset \bus.
\begin{quote}
\em n.b.\ this section assumes a knowledge of \bus design
\end{quote}

We first examine when a transaction occurs correctly, as designed, and then
consider various failure modes.

\subsubsection{An Ideal Transmission}
~

\begin{figure}[!h]
%\noindent\makebox[\textwidth]{%
\begin{subfigure}{\textwidth}
    \ssmall
    \begin{tikztimingtable}[timing/slope=.3]
      %       |   D1    | D0  | D1  |     MES       |
      Din  & L 1.4L8{2H} 8{2L} 8{2H} 4{2L}11{2H}0.6H H \\
      Dout & L 0.0L8{2H} 8{2L} 8{2H} 4{2L}11{2H}2.0H H \\
      \\
      Din  & L 0.2L8{2H} 8{2L} 8{2H} 4{2L}11{2H}1.8H H \\
      Dout & L 0.4L8{2H} 8{2L} 8{2H} 4{2L}11{2H}1.6H H \\
      \\
      Din  & L 0.6L8{2H} 8{2L} 8{2H} 4{2L}11{2H}1.4H H \\
      Dout & L 0.8L8{2H} 8{2L} 8{2H} 4{2L}11{2H}1.2H H \\
      \\
      Din  & L 1.0L8{2H} 8{2L} 8{2H} 4{2L}11{2H}1.0H H \\
      Dout & L 1.2L8{2H} 8{2L} 8{2H} 4{2L}11{2H}0.8H H \\
      CLK  & C 40{2C}                                C \\
           & \\
      \extracode
        \begin{pgfonlayer}{background}
          \begin{scope}[semitransparent,semithick]
            \vertlines{1,17,...,81}
          \end{scope}
          \begin{scope}[semitransparent,semithick,dashed]
            \vertlines{9,25,...,81}
          \end{scope}
          \begin{scope}[semitransparent,semithick,dashed,color=red]
            \vertlines{5,13,...,81}
          \end{scope}
          \begin{scope}[semitransparent]
            % TX
            \filldraw[yellow] ( 1,-0.5)  rectangle ( 5,-2.5);
            \filldraw[yellow] (17,-0.5)  rectangle (21,-2.5);
            \filldraw[yellow] (33,-0.5)  rectangle (37,-2.5);
            \filldraw[yellow] (49,-0.5)  rectangle (53,-2.5);
            \filldraw[yellow] (57,-0.5)  rectangle (61,-2.5);
            \filldraw[yellow] (65,-0.5)  rectangle (69,-2.5);
            \filldraw[yellow] (73,-0.5)  rectangle (77,-2.5);
            % RX
            \filldraw[yellow] (81,-6.5)  rectangle (82,-8.5);
            % Clk
            \filldraw[yellow] ( 0,-20.5) rectangle (82,-22.5);
          \end{scope}
        \end{pgfonlayer}
        \begin{scope}
          [font=\sffamily\small,shift={(-3.0em,-0.5)},anchor=east,color=blue]
          \node at (  0,   0) {TX};
          \node at (  0,  -6) {RX};
          \node at (  0, -12) {Fwd};
          \node at (  0, -19) {Ctl};
        \end{scope}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=brown]
          \foreach \x [evaluate=\x] in {1,17,...,77}
            \foreach \offset/\l in {0/Drive1,4/Latch1,8/Drive2,12/Latch2}
              \node [rotate=45] at (\x+\offset,0) {\l};
          \node[rotate=45] at (81,0) {Drive1};
        \end{scope}
        \begin{scope}
          [font=\small,anchor=south,shift={(1,-18em)}]
          \draw
            (0,0) node[] (a) {}
            (16,0) node[] (c) {}
            (32,0) node[] (e) {}
            (48,0) node[] (g) {}
            (80,0) node[] (i) {}
            (82,0) node[] (z) {\ldots};
          \node[right=4 of a] (b) {Data 1};
          \node[right=4 of c] (d) {Data 0};
          \node[right=4 of e] (f) {Data 1};
          \node[right=8 of g] (h) {End Sequence};
          \draw[->] (b.west) -- (a.east);
          \draw[<-] (c.west) -- (b.east);
          \draw[->] (d.west) -- (c.east);
          \draw[<-] (e.west) -- (d.east);
          \draw[->] (f.west) -- (e.east);
          \draw[<-] (g.west) -- (f.east);
          \draw[->] (h.west) -- (g.east);
          \draw[<-] (i.west) -- (h.east);
          %\draw[<-] (i.east) -- (z.west);
        \end{scope}
    \end{tikztimingtable}

    \begin{tikztimingtable}[timing/slope=.3]
      %       |         ACK           |
      Din  & H 1.0H4{2H}8{2L}3{2H}1.0H 0.2H8{2L}8{2H}8{2L}7{2H}1.8H H \\
      Dout & H 1.2H4{2H}8{2L}3{2H}0.8H 0.4H8{2L}8{2H}8{2L}7{2H}1.6H H \\
      \\
      Din  & H 1.4H4{2H}8{2L}3{2H}0.6H 0.6H8{2L}8{2H}8{2L}7{2H}1.4H H \\
      Dout & H 0.0H4{2H}8{2L}3{2H}2.0H 0.8H8{2L}8{2H}8{2L}7{2H}1.2H H \\
      \\
      Din  & H 0.2H4{2H}8{2L}3{2H}1.8H 1.0H8{2L}8{2H}8{2L}7{2H}1.0H H \\
      Dout & H 0.4H4{2H}8{2L}3{2H}1.6H 1.2H8{2L}8{2H}8{2L}7{2H}0.8H H \\
      \\
      Din  & H 0.6H4{2H}8{2L}3{2H}1.4H 1.4H8{2L}8{2H}8{2L}7{2H}0.6H H \\
      Dout & H 0.8H4{2H}8{2L}3{2H}1.2H 0.0H8{2L}8{2H}8{2L}7{2H}2.0H H \\
      CLK  & C 16{2C}4L15{4C}                                       H \\
      ~~~  & C 47{2C}2H                                             H \\
           & \\
      \extracode
        \begin{pgfonlayer}{background}
          \begin{scope}[semitransparent,semithick]
            \vertlines{1,17,...,32}
            \vertlines{37,53,69}
          \end{scope}
          \begin{scope}[semitransparent,semithick,dashed]
            \vertlines{9,25,...,32}
            \vertlines{97}
          \end{scope}
          \begin{scope}[semitransparent,semithick,dashed,color=red]
            \vertlines{5,13,...,32}
            \vertlines{45,61,77,85,93}
          \end{scope}
          \begin{scope}[semitransparent,semithick,color=blue]
            \vertlines{33,49,...,89}
          \end{scope}
          \begin{scope}[semitransparent,semithick,dashed,color=blue]
            \vertlines{41,57,...,89}
          \end{scope}
          \begin{scope}[semitransparent,yellow]
            % TX
            %\filldraw[yellow] ( 0,-0.5)  rectangle (1,-2.5);
            % RX
            \filldraw ( 1,-6.5)  rectangle ( 5,-8.5);
            \filldraw ( 9,-6.5)  rectangle (13,-8.5);
            \filldraw (17,-6.5)  rectangle (21,-8.5);
            \filldraw (25,-6.5)  rectangle (29,-8.5);
            % Clk
            \filldraw ( 0,-20.5) rectangle (33,-22.5);
          \end{scope}
          \begin{scope}[cyan,opacity=.25]
            \filldraw   (33,-18.5) rectangle (\twidth-1,-22.5);
          \end{scope}
        \end{pgfonlayer}
        \begin{scope}
          [font=\sffamily\small,shift={(-3.0em,-0.5)},anchor=east,color=blue]
          \node at (  0,   0) {TX};
          \node at (  0,  -6) {RX};
          \node at (  0, -12) {Fwd};
          \node at (  0, -19) {Ctl};
        \end{scope}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=brown]
          \foreach \x [evaluate=\x] in {1,17,...,29}
            \foreach \offset/\l in {0/Drive1,4/Latch1,8/Drive2,12/Latch2}
              \node [rotate=45] at (\x+\offset,0) {\l};
          \def\base{37}
          \node [rotate=45] at (\base+0, 0) {Drive1};
          \node [rotate=45] at (\base+8, 0) {Latch1};
          \node [rotate=45] at (\base+16, 0) {Drive2};
          \node [rotate=45] at (\base+24, 0) {Latch2};
          \node [rotate=45] at (\base+32, 0) {Drive1};
          \node [rotate=45] at (\base+40, 0) {Latch1};
          \node [rotate=45] at (\base+48, 0) {Reset};
          \node [rotate=45] at (\base+56, 0) {Reset};
        \end{scope}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=blue]
          \def\base{33}
          \node [rotate=45] at (\base, 0) {Reset-S0-D};
          \node [rotate=45] at (\base+8, 0) {Reset-S0-L};
          \node [rotate=45] at (\base+16, 0) {Reset-S1-D};
          \node [rotate=45] at (\base+24, 0) {Reset-S1-L};
          \node [rotate=45] at (\base+32, 0) {Reset-S0-D};
          \node [rotate=45] at (\base+40, 0) {Reset-S0-L};
          \node [rotate=45] at (\base+48, 0) {Reset-R-D};
          \node [rotate=45] at (\base+56, 0) {Reset-R-L};
          \node [rotate=45,color=black] at (\base+64, 0) {Idle};
        \end{scope}
        \begin{scope}
          [font=\small,anchor=south,shift={(1,-19.5em)}]
          \draw
            (-2,0) node[] (z) {\ldots}
            (0,0) node[] (a) {}
            (32,0) node[] (c) {}
            (97,0) node[] (e) {};
          \node[right=6 of a] (b) {Acknowledgement};
          \node[right=28 of c] (d) {Reset};
          %\draw[->] (z.east) -- (a.west);
          \draw[->] (b.west) -- (a.east);
          \draw[<-] (c.west) -- (b.east);
          \draw[->] (d.west) -- (c.east);
          \draw[<-] (e.west) -- (d.east);
        \end{scope}
    \end{tikztimingtable}
\end{subfigure}
  \label{fig:reset-normal}
%}
  \caption{A normal end sequence, showing the last three bits sent (1, 0, 1)
followed by a Message~End~Sequence and Message~Acknowledgement. During reset,
the control node halves the clock speed it puts on the bus for phase-locking.}
\end{figure}

\subsubsection{Phase Offsets}
At some point, it is possible that a node may miss a clock edge. At that
point, the node is considered out of phase. In order for the node to
successfully communicate in the future, it is necessary for the node to
re-align. We leverage the reset sequence to achieve this goal, and also
include a brief discussion of the implications of whether the node that falls
out of phase is a forwarding, transmitting, or receiving node.

For the purposes of phase, the control node is defined to always be in phase.
If a local clock glitch somehow occurs on the control node, then the entire
bus is considered out of phase from the control node and the control node will
reset the bus when it detects another node is out of phase.

In all $1\phi$ and $3\phi$ cases, the latched values are non-deterministic as
the node is sampling for its local {\sc latch2} cycle while the transmitting
node is driving the new bit. Most likely the node will latch the value that
was previously on the bus as the new bit will not have propagated to the local
{\tt DIN}. It is possible, however, that the node that is transmitting has a
lower threshold for detecting the rise of {\tt CLK} and a powerful {\tt DOUT}
driver, in which case the out-of-phase node will latch the new value.

Transmitting the same bit twice in a row is uninteresting as there are no
changes on the data lines. We examine then: TX~1$\rightarrow$0,
TX~0$\rightarrow$1, TX~1$\rightarrow$Message~End~Sequence,
the~Message~End~Sequence,
Message~End~Sequence$\rightarrow$Message~Acknowledgement,
Message~Acknowledgement$\rightarrow$Idle.

\medskip
\noindent
\begin{framed}
  \label{reset-assumption}
  \textbf{One Critical Assumption:} When nodes are $1\phi$ or $3\phi$ out of
  phase, for any member node it is non-deterministic if the new data or the
  rising clock arrives first. For the {\em control} layer, however, we must
  be able to assume that the control layer will sample its {\tt DIN} as it
  raises the {\tt CLK} line, that is {\em before} a new value could possibly
  have propogated.  This is necessary to resolve issues such as those discussed
  in $1\phi-$TX$-0\rightarrow$1~(\ref{reset-phi1-tx-0-1}).
\end{framed}

\medskip
\textbf{\textsc{Todo:}} The sample graphics do not include
TX~0$\rightarrow$~Message~End~Sequence, Message~End~Sequence$\rightarrow$Idle,
others? Does that matter?

\paragraph{$1\phi$ Offset}
~

\begin{quote}
{\em Note:} A transmitting node that is $1\phi$ off is equivalent to the rest
of the bus being $3\phi$ off, and thus need not be explicitly discussed here.
\end{quote}

A node that has missed one clock edge will be one phase behind:

\begin{figure}[!h]
\noindent\makebox[\textwidth]{%
    \tiny
    \begin{tikztimingtable}[timing/slope=.3]
      %       |  D1   |  D0   |  D1   |    MES        |   ACK               |
      Din  & L 8{1.5H} 8{1.5L} 8{1.5H} 4{1.5L}12{1.5H} 4{1.5H}8{1.5L}4{1.5H}
      %       | Reset
               8{1.5L}8{1.5H}8{1.5L}6{1.5H} H \\
      CLK  & C 56{1.5C}3L14{3C} C \\
      Bus  & D{}{12D{Data 1}}{12D{Data 0}}{12D{Data 1}}{24D{MES}}{24D{ACK}}{45D{Reset}}D \\
      \extracode
        \begin{pgfonlayer}{background}
          \begin{scope}[semitransparent,semithick,dashed,color=red]
            \vertlines{1,7,...,83}
            \vertlines{88,100,112,118,124}
          \end{scope}
          \begin{scope}[semitransparent,semithick,dashed]
            \vertlines{4,10,...,87}
            \vertlines{94,106,130}
          \end{scope}
          \begin{scope}[cyan,opacity=.25]
            % Reset
            \filldraw  (82,-.5) rectangle (130,-2.5);
          \end{scope}
        \end{pgfonlayer}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=red]
          \foreach \x [evaluate=\x] in {1,13,...,79}
            \foreach \offset/\l in {0/Latch2,3/Drive1,6/Latch1,9/Drive2}
              \node [rotate=45] at (\x+\offset,0) {\l};
          \node [rotate=45] at (88,0) {Latch2};
          \node [rotate=45] at (94,0) {Drive1};
          \node [rotate=45] at (100,0) {Latch1};
          \node [rotate=45] at (106,0) {Drive2};
          \node [rotate=45] at (112,0) {Latch2};
          \node [rotate=45] at (118,0) {Reset (D)};
          \node [rotate=45] at (124,0) {Reset (L)};
          \node [rotate=45,color=black] at (130,0) {Idle (L)};
        \end{scope}
    \end{tikztimingtable}
}
\caption{A nominal transmission (1, 0, 1, MES, ACK, Reset) labeling the states
as $1\phi$ behind. The {\tt CLK} and {\tt Bus} lines reflect the actual bus
values, not those as interpreted by the $1\phi$ behind node.
}
\label{fig:1-phi}
\end{figure}

\subparagraph{TX 1$\rightarrow$0}
In the common case, the node will latch another 1, matching the {\sc latch1}
value, deferring the issue to another possible state. If the node does catch
the new 0, it will enter the Reset state, where it will remain until it
catches the {\tt 101} phase realignment sequence.

\subparagraph{TX 0$\rightarrow$1}
\label{reset-phi1-tx-0-1}
For most nodes, this is the complement of TX~1$\rightarrow$0. However, if the
node happens to be a receiving node it will detect this as the beginning of a
Message~End~Sequence ({\tt 0111}). Figure~\ref{fig:reset-1phi-tx-0-1} details
the possible outcomes of a TX~0$\rightarrow$1 glitch.  Note the controller's
detection relies on the reset assumption~(\ref{reset-assumption}) to detect
the issue.

\subparagraph{TX 1$\rightarrow$Message End Sequence}

\subparagraph{TX 0$\rightarrow$Message End Sequence}

\subparagraph{Message End Sequence}

\subparagraph{Message End Sequence$\rightarrow$Message Acknowledgement}

\subparagraph{Message Acknowledgement}

\subparagraph{Message Acknowledgement$\rightarrow$Reset Sequence}

\begin{comment}

\begin{figure}
\begin{subfigure}{\textwidth}
    \centering
    \huge {\bf MES 0110, ACK 0110, RST 01011 Broken:}

    \tiny
    \begin{tikztimingtable}[timing/slope=.3,timing/wscale=1.0]
      Din  & L0.8L4{4L}4{4H}2{4L}0.2LLLXXHHH4H    0.5H8{2L}8{2H}8{2L}7{2H}1.5HH \\
      Dout & L0.0L4{4L}4{4H}2{4L}   LLLXXHHH4H    0.5H8{2L}8{2H}8{2L}7{2H}1.5HH \\
      ~~~~ & D{}{16D{Data 0}}{16D{Data 1}}{12D{Data 0}}{44D{Error (Forwarding)}}{28D{Reset}}D
      \\
      \\
      Din  & L3{4L}LLLXXHHH2{4H}HHHXXLLL{4L}{4L}.5L.5HHHH4H    0.8H8{2L}8{2H}8{2L}7{2H}1.2HH \\
      Dout & L3{4L}LLLXXHHH2{4H}HHHXXLLL2{4L}2{4H} HLLL8H4LLH8{2H}8{2L}7{2H}H \\
      ~~~~ & {5D{Data 0}}{32D{End Sequence}}{28D{Acknowledgement Attempt}}{32D{Error (Forwarding)}}{20D{Reset}}D \\
      %\\
      Din  & L0.5L4{4L}4{4H}3{4L}{4H}3.5H HLLL8H4LLH8{2H}8{2L}7{2H}H \\
      Dout & L0.5L4{4L}4{4H}3{4L}{4H}3.5H 8{2L}8{2H}8{2L}7{2H}2.0HH \\
      CLK  & C26{2C}4L15{4C}H \\
      \extracode
        \begin{pgfonlayer}{background}
          \begin{scope}[semitransparent,dashed]
            \vertlines{1,9,...,49}
            \pgfmathparse{\twidth-4}
            \vertlines{57,65,...,\pgfmathresult}
            \vertlines[color=red]{5,13,...,49}
            \vertlines[color=blue]{53,61,...,\pgfmathresult}
            \pgfmathparse{\twidth-1}
            \vertlines{\pgfmathresult}
          \end{scope}
          \begin{scope}[thick]
            \draw[red]   (17,-4.5)  ellipse (2 and 4);
            \draw[green] (33,-4.5)  ellipse (2 and 4);
            \draw[blue]  (47,-13.5) ellipse (3 and 1.25);
          \end{scope}
          \begin{scope}[semitransparent]
            % TX
            \filldraw[yellow]    ( 1,-0.5) rectangle ( 5,-2.5);
            \filldraw[yellow]    (17,-0.5) rectangle (21,-2.5);
            \filldraw[yellow]    (33,-0.5) rectangle (37,-2.5);
            % RX
            \filldraw[yellow]    (37,-8.5) rectangle (41,-10.5);
            \filldraw[yellow]    (45,-8.5) rectangle (49,-10.5);
            \filldraw[yellow]    (57,-8.5) rectangle (65,-10.5);
            % CLK
            \filldraw[yellow]    ( 1,-16.5) rectangle (53,-18.5);
            \filldraw[cyan,opacity=.25] (53,-14.5) rectangle (\twidth-1, -18.5);
          \end{scope}
          \foreach \n [evaluate=\n as \l using int((\n-1)/4)] in {1,5,...,\twidth}
            \draw (\n,-19) -- +(0,-.2)
              node [below,inner sep=2pt] {\scalebox{.75}{\tiny\l}};
        \end{pgfonlayer}
        \begin{scope}
          [font=\sffamily\small,shift={(-3.0em,-0.5)},anchor=east,color=blue]
          \node at (  0,   0) {TX};
          \node at (  0,  -8) {RX};
          \node at (  0, -15) {Ctl};
        \end{scope}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=brown]
          \foreach \x [evaluate=\x] in {1,17,...,47}
            \foreach \offset/\l in {0/Drive1,4/Latch1,8/Drive2,12/Latch2}
              \node [rotate=45] at (\x+\offset,0) {\l};
          \node [rotate=45] at (49,0) {Drive1};
          \def\base{57}
          \node [rotate=45] at (\base+0, 0)  {Latch1};
          \node [rotate=45] at (\base+8, 0)  {Drive2};
          \node [rotate=45] at (\base+16, 0) {Latch2};
          \node [rotate=45] at (\base+24, 0) {Drive1};
          \node [rotate=45] at (\base+32, 0) {Latch1};
          \node [rotate=45] at (\base+40, 0) {Reset};
          \node [rotate=45] at (\base+48, 0) {Reset};
          \node [rotate=45] at (\base+56, 0) {Reset};
        \end{scope}
        \begin{scope}
          [font=\bf\tiny,anchor=north,shift={(.2,-3.1em)},color=red]
          \foreach \x [evaluate=\x] in {1,17,...,47}
            \foreach \offset/\l in {0/L2,4/D1,8/L1,12/D2}
              \node [rotate=45] at (\x+\offset,0) {\l};
          \node [rotate=45] at (49,0) {L2};
          \def\base{57}
          \node [rotate=45] at (\base+0, 0)  {D1};
          \node [rotate=45] at (\base+8, 0)  {L1};
          \node [rotate=45] at (\base+16, 0) {D2};
          \node [rotate=45] at (\base+24, 0) {L2};
          \node [rotate=45] at (\base+32, 0) {D1};
          \node [rotate=45] at (\base+40, 0) {L1};
          \node [rotate=45,color=brown] at (\base+48, 0) {R};
          \node [rotate=45,color=brown] at (\base+56, 0) {R};
        \end{scope}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=blue]
          \def\base{53}
          \node [rotate=45] at (\base, 0) {Reset-S0-D};
          \node [rotate=45] at (\base+8, 0) {Reset-S0-L};
          \node [rotate=45] at (\base+16, 0) {Reset-S1-D};
          \node [rotate=45] at (\base+24, 0) {Reset-S1-L};
          \node [rotate=45] at (\base+32, 0) {Reset-S0-D};
          \node [rotate=45] at (\base+40, 0) {Reset-S0-L};
          \node [rotate=45] at (\base+48, 0) {Reset-R-D};
          \node [rotate=45] at (\base+56, 0) {Reset-R-L};
          \node [rotate=45,color=black] at (\base+64, 0) {Idle};
        \end{scope}
    \end{tikztimingtable}
    \caption{Transmitter is sending data bits 0, 1, 0 ({\tt 001100}). The
transmitter latches the receiving layer's high bit during {\sc latch2} at time
11, aborts its transmission, and begins forwarding. At time 16, the RX layer
latches a {\tt 0} when it had attempted to drive a {\tt 1}, and aborts the
transmission.}

    \begin{tikztimingtable}[timing/slope=.3]
      Din  & L0.8L4{4L}4{4H}2{4L}0.2LLLXXHHH4H     0.5H8{2L}8{2H}8{2L}7{2H}1.5HH \\
      Dout & L0.0L4{4L}4{4H}2{4L}   LLLXXHHH4U    4U.5L6{2L}8{2H}8{2L}7{2H}1.5HH \\
      ~~~~ & D{}{16D{Data 0}}{16D{Data 1}}{16D{Data 0}}{24D{Data X}}{16D{Error (Forwarding)}}{28D{Reset}}D
      \\
      \\
      Din  & L3{4L}LLLXXHHH2{4H}HHHXXLLL{4L}{4L}.5L.5HHHH4X 4X0.8X 6{2L}    8{2H}8{2L}7{2H}1.2HH \\
      Dout & L3{4L}LLLXXHHH2{4H}HHHXXLLL2{4L}{4H}4X         4X4{2H}2{2L}0.8L8{2H}8{2L}7{2H}1.2HH\\
      ~~~~ & {5D{Data 0}}{32D{End Sequence}}{28D{Acknowledgement}}{32D{Error (Forwarding)}}{20D{Reset}}D \\
      %\\
      Din  & L0.5L4{4L}4{4H}3{4L}{4H}4X   4X4{2H}2{2L}8{2H}8{2L}7{2H}1.5HH  \\
      Dout & L0.5L4{4L}4{4H}3{4L}{4H}3.5H     8{2L}8{2H}8{2L}7{2H}2.0HH \\
      CLK  & C26{2C}4L15{4C}H \\
      \extracode
        \begin{pgfonlayer}{background}
          \begin{scope}[semitransparent,dashed]
            \vertlines{1,9,...,49}
            \pgfmathparse{\twidth-4}
            \vertlines{57,65,...,\pgfmathresult}
            \vertlines[color=red]{5,13,...,49}
            \vertlines[color=blue]{53,61,...,\pgfmathresult}
            \pgfmathparse{\twidth-1}
            \vertlines{\pgfmathresult}
          \end{scope}
          \begin{scope}[thick]
            \draw[red]   (17,-4.5)  ellipse (2 and 4);
            \draw[green] (33,-4.5)  ellipse (2 and 4);
            \draw[blue]  (47,-13.5) ellipse (3 and 1.25);
          \end{scope}
          \begin{scope}[semitransparent]
            % TX
            \filldraw[yellow]    ( 1,-0.5) rectangle ( 5,-2.5);
            \filldraw[yellow]    (17,-0.5) rectangle (21,-2.5);
            \filldraw[yellow]    (33,-0.5) rectangle (37,-2.5);
            \filldraw[yellow]    (49,-0.5) rectangle (57,-2.5);
            % RX
            \filldraw[yellow]    (37,-8.5) rectangle (41,-10.5);
            \filldraw[yellow]    (45,-8.5) rectangle (49,-10.5);
            \filldraw[yellow]    (57,-8.5) rectangle (65,-10.5);
            % CLK
            \filldraw[yellow]    ( 1,-16.5) rectangle (53,-18.5);
            \filldraw[cyan,opacity=.25] (53,-14.5) rectangle (\twidth-1, -18.5);
          \end{scope}
          \foreach \n [evaluate=\n as \l using int((\n-1)/4)] in {1,5,...,\twidth}
            \draw (\n,-19) -- +(0,-.2)
              node [below,inner sep=2pt] {\scalebox{.75}{\tiny\l}};
        \end{pgfonlayer}
        \begin{scope}
          [font=\sffamily\small,shift={(-3.0em,-0.5)},anchor=east,color=blue]
          \node at (  0,   0) {TX};
          \node at (  0,  -8) {RX};
          \node at (  0, -15) {Ctl};
        \end{scope}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=brown]
          \foreach \x [evaluate=\x] in {1,17,...,47}
            \foreach \offset/\l in {0/Drive1,4/Latch1,8/Drive2,12/Latch2}
              \node [rotate=45] at (\x+\offset,0) {\l};
          \node [rotate=45] at (49,0) {Drive1};
          \def\base{57}
          \node [rotate=45] at (\base+0, 0)  {Latch1};
          \node [rotate=45] at (\base+8, 0)  {Drive2};
          \node [rotate=45] at (\base+16, 0) {Latch2};
          \node [rotate=45] at (\base+24, 0) {Drive1};
          \node [rotate=45] at (\base+32, 0) {Latch1};
          \node [rotate=45] at (\base+40, 0) {Reset};
          \node [rotate=45] at (\base+48, 0) {Reset};
          \node [rotate=45] at (\base+56, 0) {Reset};
        \end{scope}
        \begin{scope}
          [font=\bf\tiny,anchor=north,shift={(.2,-3.1em)},color=red]
          \foreach \x [evaluate=\x] in {1,17,...,47}
            \foreach \offset/\l in {0/L2,4/D1,8/L1,12/D2}
              \node [rotate=45] at (\x+\offset,0) {\l};
          \node [rotate=45] at (49,0) {L2};
          \def\base{57}
          \node [rotate=45] at (\base+0, 0)  {D1};
          \node [rotate=45] at (\base+8, 0)  {L1};
          \node [rotate=45] at (\base+16, 0) {D2};
          \node [rotate=45] at (\base+24, 0) {L2};
          \node [rotate=45] at (\base+32, 0) {D1};
          \node [rotate=45] at (\base+40, 0) {L1};
          \node [rotate=45,color=brown] at (\base+48, 0) {R};
          \node [rotate=45,color=brown] at (\base+56, 0) {R};
        \end{scope}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=blue]
          \def\base{53}
          \node [rotate=45] at (\base, 0) {Reset-S0-D};
          \node [rotate=45] at (\base+8, 0) {Reset-S0-L};
          \node [rotate=45] at (\base+16, 0) {Reset-S1-D};
          \node [rotate=45] at (\base+24, 0) {Reset-S1-L};
          \node [rotate=45] at (\base+32, 0) {Reset-S0-D};
          \node [rotate=45] at (\base+40, 0) {Reset-S0-L};
          \node [rotate=45] at (\base+48, 0) {Reset-R-D};
          \node [rotate=45] at (\base+56, 0) {Reset-R-L};
          \node [rotate=45,color=black] at (\base+64, 0) {Idle};
        \end{scope}
    \end{tikztimingtable}
    \caption{Transmitter is sending data bits 0, 1, 0 ({\tt 001100}). The
transmitter latches {\tt 0} at time 11 and does not yet know there is an
issue. At time 12, so long as the transmitter is sending another full bit
it does not matter whether that bit is a {\tt 0} or {\tt 1} as the control
layer's reset will propagate during the {\sc latch1}, {\sc drive2}, and {\sc
latch2} states.  Shown here is the assumption that the RX node latches the
previous {\tt 1} at time 12. If it had latched {\tt 0} instead it would enter
Reset at time 12.}


    \begin{tikztimingtable}[timing/slope=.3]
      Din  & L0.8L4{4L}4{4H}{4L}{4L}{4H}{4H}{4H}{4H}{4L}{4L}{16L} \\
      Dout & L0.0L4{4L}4{4H}{4L}{4L}{4H}{4H}{4H}{4H}{4L}{4L}{16L}\\
      ~~~~ & D{}{16D{Data 0}}{16D{Data 1}}{8D{MES 0}}{8D{MES 1}}{8D{MES 1}}{8D{MES 0}}{8D{ACK 0}}{8D{NAK}}
      \\
      \\
      Din  & L3{4L}LLLXXHHH2{4H}HHHXXLLL{3L}XX{3H}{4H}{4H}{3H}XX{3L}{4L}{16L} \\
      Dout & L3{4L}LLLXXHHH2{4H}HHHXXLLL{4L}{4H}{4H}{4H}{4H}X{3L}{4L}{16L} \\
      ~~~~ & {5D{Data 0}}{32D{End Sequence}}{32D{Acknowledgement}}D{} \\
      %\\
      Din  & L0.5L4{4L}4{4H}{4L}{4L}{4H}{4H}{4H}{4H}{4L}{4L}{16L} \\
      Dout & L0.5L4{4L}4{4H}{4L}{4L}{4H}{4H}{4H}{4H}{4L}{4L}{16L} \\
      %CLK  & C26{2C}4L15{4C}H \\
      CLK  & C46{2C}4L \\
      \extracode
        \begin{pgfonlayer}{background}
          \begin{scope}[semitransparent,dashed]
            \vertlines{1,9,...,49}
            \pgfmathparse{\twidth-4}
            \vertlines{57,65,...,\pgfmathresult}
            \vertlines[color=red]{5,13,...,49}
            \vertlines[color=blue]{53,61,...,\pgfmathresult}
            \pgfmathparse{\twidth-1}
            \vertlines{\pgfmathresult}
          \end{scope}
          \begin{scope}[semitransparent]
            % TX
            \filldraw[yellow]    ( 1,-0.5) rectangle ( 5,-2.5);
            \filldraw[yellow]    (17,-0.5) rectangle (21,-2.5);
            \filldraw[yellow]    (33,-0.5) rectangle (37,-2.5);
            \filldraw[yellow]    (41,-0.5) rectangle (45,-2.5);
            \filldraw[yellow]    (49,-0.5) rectangle (53,-2.5);
            \filldraw[yellow]    (57,-0.5) rectangle (61,-2.5);
            % RX
            \filldraw[yellow]    (37,-8.5) rectangle (41,-10.5);
            \filldraw[yellow]    (45,-8.5) rectangle (49,-10.5);
            \filldraw[yellow]    (53,-8.5) rectangle (57,-10.5);
            \filldraw[yellow]    (61,-8.5) rectangle (65,-10.5);
          \end{scope}
        \end{pgfonlayer}
        \begin{scope}
          [font=\sffamily\small,shift={(-3.0em,-0.5)},anchor=east,color=blue]
          \node at (  0,   0) {TX};
          \node at (  0,  -8) {RX};
          \node at (  0, -15) {Ctl};
        \end{scope}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=brown]
          \foreach \x [evaluate=\x] in {1,17,...,\twidth}
            \foreach \offset/\l in {0/Drive1,4/Latch1,8/Drive2,12/Latch2}
              \node [rotate=45] at (\x+\offset,0) {\l};
        \end{scope}
        \begin{scope}
          [font=\bf\tiny,anchor=north,shift={(.2,-3.1em)},color=red]
          \foreach \x [evaluate=\x] in {1,17,...,\twidth}
            \foreach \offset/\l in {0/L2,4/D1,8/L1,12/D2}
              \node [rotate=45] at (\x+\offset,0) {\l};
        \end{scope}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=blue]
          \def\base{53}
        \end{scope}
    \end{tikztimingtable}
    \caption{Transmitting is sending data bits 0, 1, then
Message~End~Sequence ({\tt 00110110})}
\end{subfigure}
\caption{Detail of a $1\phi$TX~0$\rightarrow$1 error. The top labels are the
current global bus state. The red labels above the RX waveform indicate the
local $1\phi$ state machine. {\tt DOUT} lines are colored to indicate when a
node is driving (yellow), otherwise it is forwarding its {\tt DIN} value.
This scheme fails in the third case (TX 0,1,MES) as the RX node can
incorrectly conclude it has ACK'd a message. While this is detectable by
observing that the ACK is not immediately followed by Reset, this is
cumbersome and not very intuitive.
}
\label{fig:reset-1phi-tx-0-1}
\end{figure}

\end{comment}

\begin{figure}[h]
\begin{subfigure}{\textwidth}
    \tiny
    \begin{tikztimingtable}[timing/slope=.3,timing/wscale=1.0]
      %       |    D0     || D1  ||   D0   {}  RD0      ||  R1D     ||  R0D     || Re-Reset
      Din  & L 0.8L  4L12L  4H12H2.2LXX3H4H  4L0.8L8L  4L4H  4H4H4H    4L4L4L 4L        \\
      Dout & L 0.0L  4L12L  4H12H  4L X3H4H  4L    8L  4H4H  4H4H4H0.8H4L4L4L 4L        \\
      ~~~~ & D{}{16D{Data 0}}{16D{Data 1}}{24D{Data 0}}{24D{Data 1}}{36D{Reset}}D \\
      \\
      Din  & L 0.0L  4L11LXX3H11HXX3L  4H4H  4L    7LXX3H4H  4H4H4H1.0H4L4L4L 4L    \\
      Dout & L 0.0L  4L11LXX3H11HXX3L  4H4H  4L    8L X3H4H  4L4L4L    4L4H4H 4L    \\
      ~~~~ & {5D{Data 0}}{32D{End Sequence}}{52D{Acknowledgement Attempt}}{36D{Error (Forwarding)}}D \\
      %\\
      Din  & L 0.5L  4L12L  4H12H  4L  4H4H  4L    8L  4H4H  4L4L4L    4L4H4H 4L   \\
      Dout & L 0.5L  4L12L  4H12H  4L3.5H4H  4L    8L  4L4H  4H4H4H    4L4L4L 4L    \\
      CLK  & C22{2C}4L15{4C}H \\
      \extracode
        \begin{pgfonlayer}{background}
          \begin{scope}[semitransparent,dashed]
            \vertlines{1,9,...,41}
            \pgfmathparse{\twidth-4}
            \vertlines{49,57,...,\pgfmathresult}
            \vertlines[color=red]{5,13,...,41}
            \vertlines[color=blue]{45,53,...,\pgfmathresult}
            \pgfmathparse{\twidth-1}
            \vertlines{\pgfmathresult}
          \end{scope}
          \begin{scope}[thick]
            %\draw[red]   (17,-4.5)  ellipse (2 and 4);
            %\draw[green] (33,-4.5)  ellipse (2 and 4);
            \draw[blue]  (39,-13.5) ellipse (3 and 1.25);
            \draw[blue]  (69,-14.5) ellipse (1.25 and 2);
            \draw[blue]  (85,-14.5) ellipse (1.25 and 2);
          \end{scope}
          \begin{scope}[semitransparent]
            % TX
            \filldraw[yellow]    ( 1,-0.5) rectangle ( 5,-2.5);
            \filldraw[yellow]    (17,-0.5) rectangle (21,-2.5);
            \filldraw[yellow]    (33,-0.5) rectangle (37,-2.5);
            \filldraw[yellow]    (57,-0.5) rectangle (65,-2.5);
            % RX
            \filldraw[yellow]    (37,-8.5) rectangle (41,-10.5);
            \filldraw[yellow]    (49,-8.5) rectangle (57,-10.5);
            \filldraw[yellow]    (65,-8.5) rectangle (73,-10.5);
            \filldraw[yellow]    (81,-8.5) rectangle (89,-10.5);
            % CLK
            \filldraw[yellow]    ( 1,-16.5) rectangle (45,-18.5);
            \filldraw[cyan,opacity=.25] (45,-14.5) rectangle (\twidth-1, -18.5);
          \end{scope}
          \foreach \n [evaluate=\n as \l using int((\n-1)/4)] in {1,5,...,\twidth}
            \draw (\n,-19) -- +(0,-.2)
              node [below,inner sep=2pt] {\scalebox{.75}{\tiny\l}};
        \end{pgfonlayer}
        \begin{scope}
          [font=\sffamily\small,shift={(-3.0em,-0.5)},anchor=east,color=blue]
          \node at (  0,   0) {TX};
          \node at (  0,  -8) {RX};
          \node at (  0, -15) {Ctl};
        \end{scope}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=brown]
          \foreach \x [evaluate=\x] in {1,17,...,31}
            \foreach \offset/\l in {0/Drive1,4/Latch1,8/Drive2,12/Latch2}
              \node [rotate=45] at (\x+\offset,0) {\l};
          \node [rotate=45] at (33,0) {Drive1};
          \node [rotate=45] at (37,0) {Latch1};
          \node [rotate=45] at (41,0) {Drive2};

          \def\base{49}
          \pgfmathparse{\base+0}
          \node [rotate=45] at (\pgfmathresult, 0)  {Latch2};
          \pgfmathparse{\pgfmathresult+8}
          \node [rotate=45] at (\pgfmathresult, 0)  {Drive1};
          \pgfmathparse{\pgfmathresult+8}
          \node [rotate=45] at (\pgfmathresult, 0)  {Latch1};
          \pgfmathparse{\pgfmathresult+8}
          \node [rotate=45] at (\pgfmathresult, 0)  {Drive2};
          \pgfmathparse{\pgfmathresult+8}
          \node [rotate=45] at (\pgfmathresult, 0)  {Latch2};
          \pgfmathparse{\pgfmathresult+8}
          \node [rotate=45] at (\pgfmathresult, 0)  {Drive1};
          \pgfmathparse{\pgfmathresult+8}
        \end{scope}
        \begin{scope}
          [font=\bf\tiny,anchor=north,shift={(.2,-3.1em)},color=red]
          \foreach \x [evaluate=\x] in {1,17,...,31}
            \foreach \offset/\l in {0/L2,4/D1,8/L1,12/D2}
              \node [rotate=45] at (\x+\offset,0) {\l};
          \node [rotate=45] at (33,0) {L2};
          \node [rotate=45] at (37,0) {D1};
          \node [rotate=45] at (41,0) {L1};

          \def\base{49}
          \pgfmathparse{\base+0}
          \node [rotate=45] at (\pgfmathresult, 0)  {D2};
          \pgfmathparse{\pgfmathresult+8}
          \node [rotate=45] at (\pgfmathresult, 0)  {L2};
          \pgfmathparse{\pgfmathresult+8}
          \node [rotate=45] at (\pgfmathresult, 0)  {D1};
          \pgfmathparse{\pgfmathresult+8}
          \node [rotate=45] at (\pgfmathresult, 0)  {L1};
          \pgfmathparse{\pgfmathresult+8}
          \node [rotate=45] at (\pgfmathresult, 0)  {D2};
          \pgfmathparse{\pgfmathresult+8}
          \node [rotate=45] at (\pgfmathresult, 0)  {L2};
          \pgfmathparse{\pgfmathresult+8}
        \end{scope}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=blue]
          \def\base{45}
          \pgfmathparse{\base+0}
          \node [rotate=45] at (\pgfmathresult, 0)  {R0-D};
          \pgfmathparse{\pgfmathresult+8}
          \node [rotate=45] at (\pgfmathresult, 0)  {R0-L};
          \pgfmathparse{\pgfmathresult+8}
          \node [rotate=45] at (\pgfmathresult, 0)  {R1-D};
          \pgfmathparse{\pgfmathresult+8}
          \node [rotate=45] at (\pgfmathresult, 0)  {R1-L};
          \pgfmathparse{\pgfmathresult+8}
          \node [rotate=45] at (\pgfmathresult, 0)  {R0-D};
          \pgfmathparse{\pgfmathresult+8}
          \node [rotate=45] at (\pgfmathresult, 0)  {R0-L};
          \pgfmathparse{\pgfmathresult+8}
          \node [rotate=45] at (\pgfmathresult, 0)  {R0-D};
          \pgfmathparse{\pgfmathresult+8}
          \node [rotate=45] at (\pgfmathresult, 0)  {R0-L};
          \pgfmathparse{\pgfmathresult+8}
          \node [rotate=45] at (\pgfmathresult, 0)  {R1-D};
          \pgfmathparse{\pgfmathresult+8}
          \node [rotate=45] at (\pgfmathresult, 0)  {R1-L};
          \pgfmathparse{\pgfmathresult+8}
          \node at (\pgfmathresult, 0)  {\normalsize\ldots};
          %\pgfmathparse{\pgfmathresult+8}
          %\node [rotate=45] at (\pgfmathresult, 0)  {R0-L};
          %\pgfmathparse{\pgfmathresult+8}
          %\node [rotate=45] at (\pgfmathresult, 0)  {R1-I};
          %\pgfmathparse{\pgfmathresult+8}
          %\node [rotate=45] at (\pgfmathresult, 0)  {R1-I};
          %\pgfmathparse{\pgfmathresult+8}
        \end{scope}
    \end{tikztimingtable}
    \caption{Transmitter is sending data bits 0, 1, 0 ({\tt 001100}). If the
      transmitter had sent 0, 1, 1 ({\tt 001111}) or 0, 1, MES ({\tt
      00110111}) The attempt to latch a 1 during {\sc latch2} at time 12 would
      have failed and the transmitter would simply enter Reset and begin
      forwarding earlier.
    }
\end{subfigure}
\caption{Detail of a $1\phi$TX~0$\rightarrow$1 error. The top labels are the
current global bus state. The red labels above the RX waveform indicate the
local $1\phi$ state machine. {\tt DOUT} lines are colored to indicate when a
node is driving (yellow), otherwise it is forwarding its {\tt DIN} value.
}
\label{fig:reset-1phi-tx-0-1}
\end{figure}
