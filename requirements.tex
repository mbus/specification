\svnInfo $Id$

\section{Requirements \& Design Considerations}
\label{sec:requirements}
\label{sec:design}
This section attempts to explain the design tradeoffs made in the \bus design.

\paragraph{Define bus PHY, MAC and application logic interface}
We take a vertical integration approach, controlling more of the complete
stack in an effort to obtain every available ounce of energy efficiency within
our further design constraints.

\paragraph{Must be fully-synthesizable}
In an effort to make \bus ubiquitous, it is important that other designers can
easily add \bus to their systems/chips. In practice, this means a
fully-synthesizable design such that simple, pure verilog can be given to any
individual wishing to implement \bus. The provides added advantages in
pre-silicon testing and validation. One thought was using both {\tt CLK} edges
to alternate {\sc drive} and {\sc latch} states to reduce the power draws by
{\tt CLK} wire. However, using both edges requires a custom designed flip-flop
which is not supported by commom standard cell library. Using single edge 
trigger has worse energy-per-bit but retains better portability.

\paragraph{Optimize for synthesis simplicity over speed}
The synthesizability is paramount. While it is possible to build hardware the
latches on both the rising and falling clock edge, it is harder to design this
in Verilog. When faced with such tradeoffs, efficiency loses to simplicity /
synthesizability.

\paragraph{Must be low-power}
The \bus was designed for the Michigan Micro Mote~(M3) project. The system is
designed to run off a 0.5~$\mu$Ah battery. To serve as a feasible
communication bus, the energy consumption must be on the order of $pW$.
%XXX: Ballpark expected transaction sizes, frequency, etc -- actual energy budget.

\paragraph{Support Multi-master operation / bus arbitration / avoid race
conditions}
As every layer is capable of entering an extreme low-power state, any layer
must be capable of waking the system. The waking layer must also be capable of
communicating (i) who woke the system and (ii) why. While such a system could
query (ii) given (i), determining who woke the system requires a complex
dedicated controller, or for the waking layer to simply announce it. A
multi-master bus greatly simplifies the software design and allows for things
such as DMA from an imager chip to a radio chip, without necessarily requiring
CPU intervention.

Once multi-master is agreed upon, some form of arbitration scheme must be
devised, as well as consideration for races as multiple layers attempt to
acquire the bus.

\paragraph{Minimize pins}
\paragraph{Minimize gates}
\paragraph{Limit to four I/O pads}
The physical area of the M3 system is extremely constrained. There is only
room for four I/O {\em pads} on each layer of the system (keep in mind that
forming a net/bus still requires two {\em pads} when wirebonding).

\paragraph{Minimize timing uncertainty/latency/jitter}

\paragraph{Allow for wakeup that takes time}
As the system supports extremely low-power sleep, the bus must tolerate /
account for a lag in waking layers of the system up. In practice this is
mostly a focus on the bus layer controller for each layer at first, followed
by layer-specific concerns of how much local buffer should be necessary and
when/how to wake the proper layer.

\paragraph{Active vs sleep mode; want backward compatibility}
The bus needs an idle state that consumes very little power. Ideally, each
layer not participating in the current transaction also burns very little
power.

There should also be some consideration for future-proof design, that is the
introduction of a newer protocol that can run on the bus that older
controllers can silently ignore.

\paragraph{Ensure that bus reset is possible}
Stuff happens. It is important that there exists some kind of escape hatch to
rescue / reset the bus.

\paragraph{Support variable-length packet sizes}
Short packet length limits (e.g. order 4~bytes) lead to unacceptably high
protocol overheads for large (order 1~kB+) messages. An upper bound on
packet-length leads to possibly complex software-level fragmentation schemes
(or worse hardware-level if the bus packet length $<$ message buffer).

A leading length field with a reasonably large upper bound would then be
acceptable, although not ideal. The goal is to allow for true arbitrary length
packets if possible.

\paragraph{Consider automatic address space management protocol?}
There is an extensibility / simplicity trade-off. I2C only allowed for 128
addresses, which for an individual bus instance was seen as more than enough
(still pretty true with the loading requirements, but repeaters / extenders
make that less true). The real issue though is address space collisions
between generic components. To build a plug 'n play bus of any arbitrary
pieces requires the whole corpus of parts to have non-conflicting addresses.
This motivates extensibility.

Addressing has not yet been defined. It would be interesting to do the math
and see what percentage of addresses a lost to a scheme such as `no legal
address ends in 00', allowing easy, endless extensibility, but at XX\% cost?

\paragraph{Allow interposing of the bus to read out / insert data from
external source}
Sniffing pretty much any bus design is easy, but adding devices post-hoc is a
harder requirement. There is great motivation for transient connection of
devices (programmer, debugger, etc), and also some motivation for the ability
to permanently add new devices to an existing bus.

A reasonable argument for the permanent addition is that the addition /
removal is so infrequent that it can be an intrusive process; unless something
like a pre-packaged IC had a \bus internally and there was desire to allow the
possible addition of external components? In that case though, why not simply
use a separate bus, or leverage the same mechanism as...

Transient additions to the bus are much less negotiable. It's not immediately
obvious if there are examples beyond a programmer / debugger, but those two
are sufficiently critical as to motivate the need for some kind of external
transient device.

\paragraph{Must be uni-directional}
Bi-Directional analog hardware is complex and not synthesizable.

\paragraph{Endianness}
\subparagraph{Byte-Level}
No specific design consideration here per se. Given that \bus supports
messages of an arbitrary length, it simply felt more logical to send bytes
from 0{\ldots}N instead of N{\ldots}0.
\subparagraph{Bit-Level}
Again an arbitrary decision. The first test implementation elected to use MSB
and the decision was made.

\paragraph{Retransmission}
Hardware retransmission carries risks of accidentally locking up the bus,
endlessly retransmitting. While ideas such as a maximum retry count (SMBus)
mitigate this, the added complexity and risk of a hardware retransmission tip
the scales in favor of pushing the retransmission decisions to software.

To provide the software layer with more information, we choose to require the
indication of the number of bytes actually transmitted. While transient faults
could certainly occur, it is reasonable that the software can infer different
{\em probable} causes from the amount of the message that was transmitted.

\paragraph{Flow Control}
Any form of flow control requires communication {\em mid-transmission} between
the transmitting and receiving node. This could be accomplished by
periodically (e.g. every word) switching roles, but this introduces a large
amount of complexity. Another solution is an open-collector style bus (e.g.
I2C), but such designs were ruled out previously for power and
synthesizability considerations.

Our resulting selection trades simplicity for efficiency w.r.t.\ flow control.
If a receiving node's RX buffer is overrun, it may (but is not required to)
issue a Bus~Reset. Otherwise an entire message must be transmitted before any
indication of failure or success is indicated.

In practice, transmitting nodes should consider sending some form of {\em
ping} message to a destination node to validate its presence before sending a
large transmission to minimize waste if the destination node is not actually
present. \bus is not designed for a changing topology, as such discovery of
this nature need only be performed once and the amortized cost is considered
negligible.

\paragraph{Acknowledgement granularity}
As \bus supports messages of arbitrary length, a natural question arises for
the granularity of acknowledgements. At one extreme, designs such as I2C elect
to acknowledge every byte. \bus takes the opposite approach, providing only a
single acknowledgement at the end of a transmission in an all-or-nothing
fashion. The rationale for this decision again returns to simplicity and
efficiency in design. While a receiver-driven acknowledgement cycle could
easily be added every \nth{33} bit, the relative merits of this are not great.
Assuming a receiver exists on the bus, by not electing to issue a Bus~Rest, a
receiver implicitly ACKs every bit sent. A receiver that has occasion to NAK a
transmission may do so at any time during transmission. Transient faults, e.g.
a missed clock edge, will cause the node to fall into reset
(see~\ref{sec:design-reset}), in which case the message will not be ACK'd---a
single data-bit error would require a node to miss four consecutive clock
edges, which is considered extremely unlikely. The remaining consideration
then is the absent receiver, which is a relative non-issue for a bus such as
\bus with a static topology.

\paragraph{Streaming}
Some bus designs incorporate a ``streaming'' mode, which allows for a series
of physical bus transactions to be considered one continguous message at the
receiving layer. As \bus allows for arbitrary length messages, such a feature
becomes largely unnecessary, and \bus defines no streaming primative.

\paragraph{Avoid ratioed-logic, avoid timing constraints}

\paragraph{Idle State Should Be High}
We probably don't have to mention this, but it's important that they are high
since we can pull down a node with minimum power consumption (vs pulling a
node high). When a node pulls low, the pmu is still in standby mode so,
there's not much power.  I'm not sure if we want to get into the power budgets
of the nodes in different modes - it will depend on the pmu design...

\paragraph{Consider Arbitration as DOUT and CLK low?}
\label{todo:wakeup}
{\em M3 implentations note:} One more note on this time: currently, the spec
requires that the pmu resides with the ctr processor, since it's the only node
that is definitely aware of a wakeup.  However, if the ctr instead pulls down
right way on clk (not data), which does not take much power, then all nodes
will know that a bus request has been detected and the pmu can reside on any
node.  The ctr that would have to delay before raising the clk to allow the
pmu to switch mode etc...

{\em Response:} The falling edge after $t_{long}$ is sufficient for the
initial waking of nodes, or the rising edge of the arbitration (doesn't
matter). The bus expects the data lines to be stable during the window between
arbitration resolution and the first {\sc drive1} cycle, but the bus itself
ignores the lines during this window. For the M3 power wake-up, we can stretch
the \bus~{\tt CLK} line and have the control layer toggle the data lines to
generate the needed state edges for layer wake-up. Non-M3 layers will ignore
this wake-up. Things get a little funny as a non-M3 controller will need to
M3-aware, but that's not an impossible case to handle. \hl{TODO: Consider this
as possibly part of the spec?}

\subsection{Reset Design}
\label{sec:design-reset}
The reset mechanism is the \bus escape hatch. Its reliability is a first
order design constraint, and here we attempt to demonstrate how the reset
mechanism can in all possible states reliably reset \bus. Some other possible
reset designs and their shortcomings are discussed in
Appendix~\ref{sec:appendix-reset}.
\begin{quote}
\em n.b.\ this section assumes a knowledge of \bus design. New readers should
skip this section.
\end{quote}

We first examine when a transaction occurs correctly, as designed, and then
consider various failure modes.

\subsubsection{An Ideal Transmission}
~

\begin{figure}[!h]
\begin{subfigure}{\textwidth}
    \scriptsize
    \begin{tikztimingtable}[timing/slope=.3]
      %       |   D1    | D0  | D1  |     MES       | ACK 1      0      |
      Din  & L 1.4L8{2H} 8{2L} 8{2H} 4{2L}3{2H}0.6H  1.0H4{2H} 3{2L}1.0L L \\
      Dout & L 0.0L8{2H} 8{2L} 8{2H} 4{2L}3{2H}2.0H  1.2H4{2H} 3{2L}0.8L L \\
      \\
      Din  & L 0.2L8{2H} 8{2L} 8{2H} 4{2L}3{2H}1.8H  1.4H4{2H} 3{2L}0.6L L \\
      Dout & L 0.4L8{2H} 8{2L} 8{2H} 4{2L}3{2H}1.6H  0.0H4{2H} 3{2L}2.0L L \\
      \\
      Din  & L 0.6L8{2H} 8{2L} 8{2H} 4{2L}3{2H}1.4H  0.2H4{2H} 3{2L}1.8L L \\
      Dout & L 0.8L8{2H} 8{2L} 8{2H} 4{2L}3{2H}1.2H  0.4H4{2H} 3{2L}1.6L L \\
      \\
      Din  & L 1.0L8{2H} 8{2L} 8{2H} 4{2L}3{2H}1.0H  0.6H4{2H} 3{2L}1.4L L \\
      Dout & L 1.2L8{2H} 8{2L} 8{2H} 4{2L}3{2H}0.8H  0.8H4{2H} 3{2L}1.2L L \\
      CLK  & C 32{2C}                                    4{2C} 4{2C}     L \\
           & \\
      \extracode
        \begin{pgfonlayer}{background}
          \begin{scope}[semitransparent,semithick]
            \pgfmathparse{\twidth-17}
            \vertlines{1,17,...,\pgfmathresult}
            \pgfmathparse{\twidth-1}
            \vertlines[color=blue]{\pgfmathresult}
          \end{scope}
          \begin{scope}[semitransparent,semithick,dashed]
            \vertlines{9,25,...,\twidth}
          \end{scope}
          \begin{scope}[semitransparent,semithick,dashed,color=red]
            \vertlines{5,13,...,\twidth}
          \end{scope}
          \begin{scope}[semitransparent]
            % TX
            \filldraw[yellow] ( 1,-0.5)  rectangle ( 5,-2.5);
            \filldraw[yellow] (17,-0.5)  rectangle (21,-2.5);
            \filldraw[yellow] (33,-0.5)  rectangle (37,-2.5);
            \filldraw[yellow] (49,-0.5)  rectangle (53,-2.5);
            \filldraw[yellow] (57,-0.5)  rectangle (61,-2.5);
            % RX
            \filldraw[yellow] (73,-6.5)  rectangle (77,-8.5);
            % Clk
            \filldraw[yellow] ( 0,-20.5) rectangle (\twidth-1,-22.5);
            \filldraw[cyan,opacity=.25] (\twidth-1, -20.5) rectangle (\twidth, -22.5);
          \end{scope}
        \end{pgfonlayer}
        \begin{scope}
          [font=\sffamily\small,shift={(-3.0em,-0.5)},anchor=east,color=blue]
          \node at (  0,   0) {TX};
          \node at (  0,  -6) {RX};
          \node at (  0, -12) {Fwd};
          \node at (  0, -19) {Ctl};
        \end{scope}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=brown]
          \pgfmathparse{\twidth-16}
          \foreach \x [evaluate=\x] in {1,17,...,\pgfmathresult}
            \foreach \offset/\l in {0/Drive1,4/Latch1,8/Drive2,12/Latch2}
              \node [rotate=45] at (\x+\offset,0) {\l};
          \pgfmathparse{\twidth-1}
          \node[rotate=45,color=blue] at (\pgfmathresult,0) {R0-D};
        \end{scope}
        \begin{scope}
          [font=\small,anchor=south,shift={(1,-18em)}]
          \draw
            (0,0) node[] (a) {}
            (16,0) node[] (c) {}
            (32,0) node[] (e) {}
            (48,0) node[] (g) {}
            (64,0) node[] (i) {}
            (80,0) node[] (k) {}
            (82,0) node[] (z) {\ldots};
          \node[right=2 of a] (b) {Data 1 (11)};
          \node[right=2 of c] (d) {Data 0 (00)};
          \node[right=2 of e] (f) {Data 1 (11)};
          \node[right=3 of g] (h) {MES (01)};
          \node[right=3 of i] (j) {ACK (10)};
          \draw[->] (b.west) -- (a.east);
          \draw[<-] (c.west) -- (b.east);
          \draw[->] (d.west) -- (c.east);
          \draw[<-] (e.west) -- (d.east);
          \draw[->] (f.west) -- (e.east);
          \draw[<-] (g.west) -- (f.east);
          \draw[->] (h.west) -- (g.east);
          \draw[<-] (i.west) -- (h.east);
          \draw[->] (j.west) -- (i.east);
          \draw[<-] (k.west) -- (j.east);
        \end{scope}
    \end{tikztimingtable}

    \begin{tikztimingtable}[timing/slope=.3]
      %       |  ACK/RST 0  1  | RST 0 11
      Din  & L 0.2L8{2L} 8{2H}  12{2L} 7{2H} 1.8H H \\
      Dout & L 0.4L8{2L} 8{2H}  12{2L} 7{2H} 1.6H H \\
      \\
      Din  & L 0.6L8{2L} 8{2H}  12{2L} 7{2H} 1.4H H \\
      Dout & L 0.8L8{2L} 8{2H}  12{2L} 7{2H} 1.2H H \\
      \\
      Din  & L 1.0L8{2L} 8{2H}  12{2L} 7{2H} 1.0H H \\
      Dout & L 1.2L8{2L} 8{2H}  12{2L} 7{2H} 0.8H H \\
      \\
      Din  & L 1.4L8{2L} 8{2H}  12{2L} 7{2H} 0.6H H \\
      Dout & L 0.0L8{2L} 8{2H}  12{2L} 7{2H} 2.0H H \\
      CLK  & L 4L  3{4C} 4{4C}  6{4C}  4{4C}      H \\
      ~~~  & L     8{2C} 8{2C}  12{2C} 8{2C}      C \\
      \extracode
        \begin{pgfonlayer}{background}
          \begin{scope}[semitransparent,semithick]
            \pgfmathparse{\twidth-1}
            \vertlines{\pgfmathresult}
          \end{scope}
          \begin{scope}[semitransparent,semithick,dashed]
            \pgfmathparse{\twidth-13}
            \vertlines{5,21,...,\pgfmathresult}
          \end{scope}
          \begin{scope}[semitransparent,semithick,dashed,color=red]
            \pgfmathparse{\twidth-5}
            \vertlines{13,29,...,\pgfmathresult,\pgfmathresult}
          \end{scope}
          \begin{scope}[semitransparent,semithick,color=blue]
            \pgfmathparse{\twidth-17}
            \vertlines{1,17,...,\pgfmathresult}
          \end{scope}
          \begin{scope}[semitransparent,semithick,dashed,color=blue]
            \pgfmathparse{\twidth-9}
            \vertlines{9,25,...,\pgfmathresult,\pgfmathresult}
          \end{scope}
          \begin{scope}[semitransparent,yellow]
            % TX
            %\filldraw[yellow] ( 0,-0.5)  rectangle (1,-2.5);
            % RX
            %\filldraw ( 1,-6.5)  rectangle ( 5,-8.5);
            % Clk
            \filldraw ( 0,-20.5) rectangle (1,-22.5);
          \end{scope}
          \begin{scope}[cyan,opacity=.25]
            \filldraw   (1,-18.5) rectangle (\twidth-1,-22.5);
          \end{scope}
        \end{pgfonlayer}
        \begin{scope}
          [font=\sffamily\small,shift={(-3.0em,-0.5)},anchor=east,color=blue]
          \node at (  0,   0) {TX};
          \node at (  0,  -6) {RX};
          \node at (  0, -12) {Fwd};
          \node at (  0, -19) {Ctl};
        \end{scope}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=brown]
          \def\base{5}
          \node [rotate=45] at (\base+0, 0) {Drive1};
          \node [rotate=45] at (\base+8, 0) {Latch1};
          \node [rotate=45] at (\base+16, 0) {Drive2};
          \node [rotate=45] at (\base+24, 0) {Latch2};
          \node [rotate=45] at (\base+32, 0) {Drive1};
          \node [rotate=45] at (\base+40, 0) {Latch1};
          \node [rotate=45] at (\base+48, 0) {Phase-Align};
          \node [rotate=45] at (\base+56, 0) {Reset$_{1}$};
          \node [rotate=45] at (\base+64, 0) {Reset$_{2}$};
        \end{scope}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=blue]
          \def\base{1}
          \node [rotate=45] at (\base+0, 0) {R0-D};
          \node [rotate=45] at (\base+8, 0) {R0-L};
          \node [rotate=45] at (\base+16, 0) {R1-D};
          \node [rotate=45] at (\base+24, 0) {R1-L};
          \node [rotate=45] at (\base+32, 0) {R0-D};
          \node [rotate=45] at (\base+40, 0) {R0-L};
          \node [rotate=45] at (\base+48, 0) {R-Align};
          \node [rotate=45] at (\base+56, 0) {R1-I$_{1}$-L};
          \node [rotate=45] at (\base+64, 0) {R1-I$_{2}$-L};
          \node [color=black] at (\base+72, 0) {Idle};
        \end{scope}
        \begin{scope}
          [font=\small,anchor=south,shift={(1,-18em)}]
          \draw
            (-2,0) node[] (z) {\ldots}
            (0,0) node[] (c) {}
            (\twidth-2,0) node[] (e) {};
          \node[right=30 of c] (d) {Reset (010..11)};
          \draw[->] (d.west) -- (c.east);
          \draw[<-] (e.west) -- (d.east);
        \end{scope}
    \end{tikztimingtable}
\end{subfigure}
  \label{fig:reset-normal}
%}
  \caption{A normal end sequence, showing the last three bits sent (1, 0, 1)
followed by a Message~End~Sequence,Message~Acknowledgement, and Reset. During
reset, the control node halves the clock speed it puts on the bus for
phase-locking.
}
\end{figure}

We are able to gaurentee that once the introduction of faults is
removed, the \bus can reset and all nodes are phase-aligned and prepared to
communicate. We make no gaurentees in the presence of faults however---there
is no parity, no CRC---, it is expected that faults should be an exceptional
circumstance in a well-designed \bus implementation. Below we discuss the
behavior of \bus given various faults and prove the bus resets successfully.

\subsubsection{Phase Offsets}
At some point, it is possible that a node may miss a clock edge (or high
capactiance on the {\tt CLK} line delays a node detecting edges, or coupling
induces an edge, etc, etc). At that point, the node is considered out of
phase. In order for the node to successfully communicate in the future, it is
necessary for the node to re-align. We leverage the reset sequence to achieve
this goal, and also include a brief discussion of the implications of whether
the node that falls out of phase is a forwarding, transmitting, or receiving
node.

For the purposes of phase, the control node is defined to always be in phase.
If a local clock glitch somehow occurs on the control node, then the entire
bus is considered out of phase from the control node and the control node will
reset the bus when it detects another node is out of phase.

In all $1\phi$ and $3\phi$ cases, the latched values are non-deterministic as
the node is sampling for its local {\sc latch1/latch2} cycle while the
transmitting node is driving the new bit. Most likely the node will latch the
value that was previously on the bus as the new bit will not have propagated
to the local {\tt DIN}. It is possible, however, that the node that is
transmitting has a lower threshold for detecting the rise of {\tt CLK} and a
powerful {\tt DOUT} driver, in which case the out-of-phase node will latch the
new value.

Transmitting the same bit twice in a row is uninteresting as there are no
changes on the data lines. We examine then: TX~1$\rightarrow$0,
TX~0$\rightarrow$1, TX~1$\rightarrow$Message~End~Sequence,
Message~End~Sequence$\rightarrow$Message~Acknowledgement,
Message~Acknowledgement$\rightarrow$Reset.

\medskip
\noindent
\begin{framed}
  \label{reset-assumption}
  \textbf{One Critical Assumption:} When nodes are $1\phi$ or $3\phi$ out of
  phase, for any member node it is non-deterministic if the new data or the
  rising clock arrives first. For the {\em control} layer, however, we must
  be able to assume that the control layer will sample its {\tt DIN} as it
  raises the {\tt CLK} line, that is {\em before} a new value could possibly
  have propogated. This feature enables the control node to detect, and
  correct, out of phase nodes.
\end{framed}

\paragraph{$1\phi$ Offset}
~

A node that has missed one clock edge will be one phase behind:

\begin{figure}[!h]
\noindent\makebox[\textwidth]{%
    \tiny
    \begin{tikztimingtable}[timing/slope=.3]
      %       |  D0   |  D1   |  D0   |  D1   |    MES 01     |
      %       |   ACK   10   | ACK/RST 01   | 0 Reset P11 | Idle
      Din  & L 8{1.5L} 8{1.5H} 8{1.5L} 8{1.5H} 4{1.5L} 4{1.5H}
               4{1.5H}4{1.5L} 8{1.5L}8{1.5H} 8{1.5L}4{1.5L}6{1.5H} 4{1.5H} H \\
      CLK  & C 8{1.5C} 8{1.5C} 8{1.5C} 8{1.5C} 4{1.5C} 4{1.5C}
               4{1.5C}4{1.5C} 3L3{3C}  4{3C}   4{3C}  2{3C}  3{3C}   2{3C} C \\
      Bus  & D{}{12D{Data 0}}{12D{Data 1}}{12D{Data 0}}{12D{Data 1}}{12D{MES 01}}
               {12D{ACK 10}}{27D{ACK/RST 010}} {30D{Reset 11}}D \\
      \extracode
        \begin{pgfonlayer}{background}
          \begin{scope}[semitransparent,semithick,dashed,color=red]
            \vertlines{1,7,...,71}
            \vertlines{76,88,100,106,112,118,124}
          \end{scope}
          \begin{scope}[semitransparent,semithick,dashed]
            \vertlines{4,10,...,75}
            \vertlines{82,94,130}
          \end{scope}
          \begin{scope}[cyan,opacity=.25]
            % Reset
            \filldraw  (73,-.5) rectangle (\twidth-1,-2.5);
          \end{scope}
          \foreach \n [evaluate=\n as \l using int((\n-1)/3)] in {1,4,...,\twidth}
            \draw (\n,-5) -- +(0,-.2)
              node [below,inner sep=2pt] {\scalebox{.75}{\tiny\l}};
        \end{pgfonlayer}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=red]
          \foreach \x [evaluate=\x] in {1,13,...,67}
            \foreach \offset/\l in {0/Latch2,3/Drive1,6/Latch1,9/Drive2}
              \node [rotate=45] at (\x+\offset,0) {\l};
          \def\base{76}
          \node [rotate=45] at (\base+0,0) {Latch2};
          \node [rotate=45] at (\base+6,0) {Drive1};
          \node [rotate=45] at (\base+12,0) {Latch1};
          \node [rotate=45] at (\base+18,0) {Drive2};
          \node [rotate=45] at (\base+24,0) {Latch2};
        \end{scope}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=blue]
          \def\base{76}
          \node [rotate=45] at (\base+30,0) {Reset (Phase)};
          \node [rotate=45] at (\base+36,0) {Reset (Phase)};
          \node [rotate=45] at (\base+42,0) {Reset$_{1}$};
          \node [rotate=45] at (\base+48,0) {Reset$_{2}$};
          \node [rotate=45,color=black] at (\base+54,0) {Idle (L)};
        \end{scope}
    \end{tikztimingtable}
}
\caption{A nominal transmission (0, 1, 0, 1, MES, ACK, Reset) labeling the
states as $1\phi$ behind. The {\tt CLK} and {\tt Bus} lines reflect the actual
bus values, not those as interpreted by the $1\phi$ behind node except during
reset where they necessarily re-align.
}
\label{fig:1-phi}
\end{figure}

\subparagraph{Forwarding Nodes}
There is not much attention paid to forwarding nodes in these breakdowns, as
the only concern is a forwarding node inadvertantly entering Reset and
progressing all the way to idle. A forwarding node can pre-emptively enter
Reset in two possible cases:

\begin{itemize}
  \item {\bf 0$\rightarrow$1$\rightarrow$0:} Referring to local $1\phi$
states, the node would have to {\sc latch2} a~0 from Data bit~0 as data is
rising, then it will unconditionally {\sc latch1} a~1 during the global {\sc
drive2} as data is stable, and finally it must {\sc latch2} a~0 as data is
falling. The next edge is the phase-alignment/entry into reset and {\tt DIN}
is ignored, the ignored edge is the global {\sc drive2} of Data 0. In Reset, a
node is seeking either a {\tt 11} or a {\tt 011} sequence. This will reliably
fail for a transmission of Data 0, however for a subsequent Data 1 or
Message~End~Sequence it is possible to read this as a false entry into Idle.
The subsequent bits of the transaction will appear as a new transmission, and
in the absolute worst case it is plausible (if not probable) that the
remaining bits align with this node's address.

  \item {\bf 0$\rightarrow$MES$\rightarrow$ACK:} Referring to times in
Figure~\ref{fig:1-phi} for clarity, the {\tt 010} sequence would be latched at
times 18, 20, and 22. The edge at time 23 is ignored for phase-alignment. Then
the edges at times 25 and 27 would register as a {\tt 00} sequence, which is
illegal. The latch history register will again match a reset at time 33. The
edge at 35 is ignored as the phase-alignment edge and 37, 39, and 41 form a
{\tt 011} reset sequence.
\end{itemize}

\begin{figure}[htb]
  \ssmall
  \begin{tikztimingtable}[timing/slope=.3,timing/wscale=1.0]
    %                                         ||||
    Din  & H 1.0H 8{2L}1.0H4{2H}HXXL1{2L}4.0L 0.5L16H 16L 16H        \\
    Dout & H 0.0H 8{2L}2.0H4{2H}HXXL1{2L}4.0L     4.0L\\
    ~~~~ & D{} {16D{Data 0}}{16D{Data 1}}{24D{Data 0}}{16D{Err (FWD)}}{12D{Reset}} \\
    \\
    Din  & H 0.0H 7{2L}LXXH5{2H}1.0H2{2L}3.0L 0.5L4.0L\\
    Dout & H 0.0H 7{2L}LXXH5{2H}    2{2L}4.0L 0.5L4.0L\\
    ~~~~ & 5D{} {16D{MES 01}}{20D{ACK 10}} \\
    %\\
    Din  & H 0.8H 8{2L}    6{2H}    2{2L}4.0L     4.0L\\
    Dout & H 0.8H 8{2L}    6{2H}    2{2L}3.2L     16H 16L 16H      \\
    CLK  & C      8{2C}    6{2C}    2{2C}2{2C}    4L 11{4C} C         \\
    \extracode
      \begin{pgfonlayer}{background}
        \begin{scope}[semitransparent,dashed]
          \vertlines{1,9,...,49}
          \pgfmathparse{\twidth-4}
          \vertlines{49,57,...,\pgfmathresult}
          \vertlines[color=red]{5,13,...,49}
          \vertlines[color=blue]{53,61,...,\pgfmathresult}
        \end{scope}
        \begin{scope}[thick]
          \draw[blue]  (31,-13.5) ellipse (3 and 1.25);
          \draw[blue]  (45,-14.5) ellipse (1.25 and 2);
        \end{scope}
        \begin{scope}[semitransparent]
          % TX
          \filldraw[yellow]    ( 1,-0.5) rectangle ( 5,-2.5);
          \filldraw[yellow]    (17,-0.5) rectangle (21,-2.5);
          \filldraw[yellow]    (33,-0.5) rectangle (37,-2.5);
          % RX
          \filldraw[yellow]    (29,-8.5) rectangle (33,-10.5);
          % CLK
          \filldraw[yellow]    ( 1,-16.5) rectangle (37,-18.5);
          \filldraw[cyan,opacity=.25] (37,-14.5) rectangle (\twidth, -18.5);
        \end{scope}
        \foreach \n [evaluate=\n as \l using int((\n-1)/4)] in {1,5,...,\twidth}
          \draw (\n,-19) -- +(0,-.2)
            node [below,inner sep=2pt] {\scalebox{.75}{\tiny\l}};
      \end{pgfonlayer}
      \begin{scope}
        [font=\sffamily\small,shift={(-3.0em,-0.5)},anchor=east,color=blue]
        \node at (  0,   0) {TX};
        \node at (  0,  -8) {RX};
        \node at (  0, -15) {Ctl};
      \end{scope}
      \begin{scope}
        [font=\sc\tiny,anchor=north,shift={(0,3em)},color=brown]
        \foreach \x [evaluate=\x] in {1,17,...,17}
          \foreach \offset/\l in {0/Drive1,4/Latch1,8/Drive2,12/Latch2}
            \node [rotate=45] at (\x+\offset,0) {\l};
        \node [rotate=45] at (33,0) {Drive1};

        \def\base{41}
        \pgfmathparse{\base+0}
        \node [rotate=45] at (\pgfmathresult, 0)  {Latch1};
        \pgfmathparse{\pgfmathresult+8}
        \node [rotate=45] at (\pgfmathresult, 0)  {Drive2};
        \pgfmathparse{\pgfmathresult+8}
        \node [rotate=45] at (\pgfmathresult, 0)  {Latch2};
        \pgfmathparse{\pgfmathresult+8}
        \node [rotate=45] at (\pgfmathresult, 0)  {Drive1};
        \pgfmathparse{\pgfmathresult+8}
        \node [rotate=45] at (\pgfmathresult, 0)  {Latch1};
        \pgfmathparse{\pgfmathresult+8}
        \node [rotate=45] at (\pgfmathresult, 0)  {Drive2};
        \pgfmathparse{\pgfmathresult+8}
      \end{scope}
      \begin{scope}
        [font=\bf\tiny,anchor=north,shift={(.2,-3.1em)},color=red]
        \node [rotate=45] at ( 1,0) {**};
        \foreach \x [evaluate=\x] in {5,21,...,35}
          \foreach \offset/\l in {0/D1,4/L1,8/D2,12/L2}
            \node [rotate=45] at (\x+\offset,0) {\l};

        \def\base{41}
        \pgfmathparse{\base+0}
        \node [rotate=45] at (\pgfmathresult, 0)  {D1};
        \pgfmathparse{\pgfmathresult+8}
        \node [rotate=45] at (\pgfmathresult, 0)  {L1};
        \pgfmathparse{\pgfmathresult+8}
        \node [rotate=45] at (\pgfmathresult, 0)  {D2};
        \pgfmathparse{\pgfmathresult+8}
        \node [rotate=45] at (\pgfmathresult, 0)  {L2};
        \pgfmathparse{\pgfmathresult+8}
        \node [rotate=45] at (\pgfmathresult, 0)  {D1};
        \pgfmathparse{\pgfmathresult+8}
        \node [rotate=45] at (\pgfmathresult, 0)  {L1};
        \pgfmathparse{\pgfmathresult+8}
      \end{scope}
      \begin{scope}
        [font=\sc\tiny,anchor=north,shift={(0,3em)},color=blue]
        \def\base{37}
        \pgfmathparse{\base+0}
        \node [rotate=45] at (\pgfmathresult, 0)  {R0-D};
        \pgfmathparse{\pgfmathresult+8}
        \node [rotate=45] at (\pgfmathresult, 0)  {R0-L};
        \pgfmathparse{\pgfmathresult+8}
        \node [rotate=45] at (\pgfmathresult, 0)  {R1-D};
        \pgfmathparse{\pgfmathresult+8}
        \node [rotate=45] at (\pgfmathresult, 0)  {R1-L};
        \pgfmathparse{\pgfmathresult+8}
        \node [rotate=45] at (\pgfmathresult, 0)  {R0-D};
        \pgfmathparse{\pgfmathresult+8}
        \node [rotate=45] at (\pgfmathresult, 0)  {R0-L};
        \pgfmathparse{\pgfmathresult+9}
        \node at (\pgfmathresult, -1)  {\normalsize \ldots};
      \end{scope}
  \end{tikztimingtable}
  \caption{{\em TX 0$\rightarrow$1 False MES~~}
We assume the RX latches 0 at time 4, creating the problem. The TX may
possibly be reset at time 7 if it latched 1, here we assume not. At time 8 the
control layer detects a change between {\sc latch2} and {\sc drive1}, alerting
it to the issue and entering Reset. We show the next TX half-bit to be 0 (and
thus a Data 0) as if it was a 1, the TX layer would reset at time 10.
  }
  \label{fig:1phi-1-0}
\end{figure}

\subparagraph{TX 1$\rightarrow$0}
If an offset node latches an incoming {\tt 0}, it will have received a {\tt
10} sequence, which is illegal. A forwarding node will not notice the {\tt 01}
sequence, as the only record it has of incoming bits is its local reset
detector. If an RX node records {\tt 01}, however, it will enter the {\sc
error} state and reset the bus.

\subparagraph{TX 0$\rightarrow$1}
When an offset node latches the incoming {\tt 1} during its local {\sc latch2}
cycle, it will consider this a Message~End~Sequence ({\tt 01}). If the $1\phi$
slip occurs at the RX node, it will begin Acknowledgement out of phase.
Figure~\ref{fig:1phi-1-0} details the possible cases, all of which result in a
sucessfully reset bus with all nodes having aborted the transaction.

\subparagraph{TX 1$\rightarrow$Message End Sequence}
An offset node will read the leading low half-bit of the
Message~End~Sequence, generating a {\tt 10} sequence, which will cause the
node to abort the transmission and enter {\sc error}.

\subparagraph{TX 0$\rightarrow$Message End Sequence}
An offset node will read the leading {\tt 0} of the Message~End~Sequence as
the second half-bit of the previous Data 0. It will then read the second
half-bit of the Message~End~Sequence as a {\tt 1} half-bit and the absence of
an Acknowledgement as the second {\tt 1} half-bit. After another {\tt 1}
half-bit, the control layer will Reset the bus following a
Message~End~Sequence with no Acknowledgement.

%%%%%%%%%%%%%%%%%%%%%% TODO
\subparagraph{Message End Sequence$\rightarrow$Message Acknowledgement}
Missing an edge on this transition will not be immediately noticed, as the
leading half-bit of Acknowledgement is also low. If a node is consistently
lagging or leading the input signal, it will fail during the control-driven
portion of acknowledgement. The implications of this for:

\begin{itemize}
  \item {\bf TX Node:} A transmitter that drops a clock after transmitting the
Message~End~Sequence may falsely interpret an ACK as a NAK.

  \item {\bf RX Node:} An RX node that drops a clock after transmitting its
first edge (that is, after the {\sc drive2} that defines ACK {\tt 01}) will
believe it acknowledged successfully, whereas the status of the TX Node is
non-deterministic.
\end{itemize}

\subparagraph{Message Acknowledgement$\rightarrow$Reset Sequence}
Unaligned edges are not possible during Reset as the data line is not driven
on a global bus clock edge. It is, however, possible that a clock edge may be
missed during Reset. Such a failure cannot be detected. The error will be
corrected during the next transaction's Reset.


\paragraph{$2\phi$ Offset}
It is extremely highly improbable that a node misses two clock edges and
directly beomes $2\phi$ offset\footnote{
  It is possible for the offset to be spread across multiple bits, e.g.
  two edges in a longs string of 0's.}.
Such a node will have missed one half-bit of a transmission. On the first
non-contiguous bit, it will detect either a false Message~End~Sequence~({\tt
10}) or an error~({\tt 01}). Any response to the false Message~End~Sequence
will be treated as a Reset by the TX node, and the RX node will at the latest
fail to align with the last two half-bits driven by the control node whilst
trying to acknowledge.


\paragraph{$3\phi$ Offset, $4\phi$ Offset}
These are both deemed extraordiarily unlikely to occur without detection as a
$1\phi$ or $2\phi$ error prior to getting this far out of alignment. The
$3\phi$ cases largely mirror the $1\phi$ cases. The $4\phi$ case is a
completely missed bit, which will result in the TX and RX nodes believing they
have completed a transaction successfully when in reality the RX node has
received one less bit than the TX node sent. The likelyhood of this occurring
it so small, and the bus is still recoverable via Reset, that it is not
considered a large concern.
