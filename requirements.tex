\svnInfo $Id$

\section{Requirements \& Design Considerations}
\label{sec:requirements}
\label{sec:design}
This section attempts to explain the design tradeoffs made in the \bus design.

\paragraph{Define bus PHY, MAC and application logic interface}
We take a vertical integration approach, controlling more of the complete
stack in an effort to obtain every available ounce of energy efficiency within
our further design constraints.

\paragraph{Must be fully-synthesizable}
In an effort to make \bus ubiquitous, it is important that other designers can
easily add \bus to their systems/chips. In practice, this means a
fully-synthesizable design, such that simple, pure verilog can be given to any
individual wishing to implement \bus. The provides added advantages in
pre-silicon testing and validation. One thought was using both {\tt CLK} edges
to alternate {\sc drive} and {\sc latch} states to reduce the power draws by
{\tt CLK} wire. However, using both edges requires a custom designed flip-flop
which is not supported by commom standard cell library. Using single edge 
trigger has worse energy-per-bit but retains better portability.

\paragraph{Optimize for synthesis simplicity over speed}
The synthesizability is paramount. While it is possible to build hardware the
latches on both the rising and falling clock edge, it is harder to design this
in Verilog. When faced with such tradeoffs, efficiency loses to simplicity /
synthesizability.

\paragraph{Must be low-power}
The \bus was designed for the Michigan Micro Mote~(M3) project. The system is
designed to run off a 0.5~$\mu$Ah battery. To serve as a feasible
communication bus, the energy consumption must be on the order of $pW$. XXX:
Ballpark expected transaction sizes, frequency, etc -- actual energy budget.

\paragraph{Support Multi-master operation / bus arbitration / avoid race
conditions}
As every layer is capable of entering an extreme low-power state, any layer
must be capable of waking the system. The waking layer must also be capable of
communicating (i) who woke the system and (ii) why. While such a system could
query (ii) given (i), determining who woke the system requires a complex
dedicated controller, or for the waking layer to simply announce it. A
multi-master bus greatly simplifies the software design and allows for things
such as DMA from an imager chip to a radio chip, without necessarily requiring
CPU intervention.

Once multi-master is agreed upon, some form of arbitration scheme must be
devised, as well as consideration for races as multiple layers attempt to
acquire the bus.

\paragraph{Minimize pins}
\paragraph{Minimize gates}
\paragraph{Limit to four I/O pads}
The physical area of the M3 system is extremely constrained. There is only
room for four I/O {\em pads} on each layer of the system (keep in mind that
forming a net/bus still requires two {\em pads} when wirebonding).

\paragraph{Minimize timing uncertainty/latency/jitter}

\paragraph{Allow for wakeup that takes time}
As the system supports extremely low-power sleep, the bus must tolerate /
account for a lag in waking layers of the system up. In practice this is
mostly a focus on the bus layer controller for each layer at first, followed
by layer-specific concerns of how much local buffer should be necessary and
when/how to wake the proper layer.

\paragraph{Active vs sleep mode; want backward compatibility}
The bus needs an idle state that consumes very little power. Ideally, each
layer not participating in the current transaction also burns very little
power.

There should also be some consideration for future-proof design, that is the
introduction of a newer protocol that can run on the bus that older
controllers can silently ignore.

\paragraph{Ensure that bus reset is possible}
Stuff happens. It is important that there exists some kind of escape hatch to
rescue / reset the bus.

\paragraph{Support variable-length packet sizes}
Short packet length limits (e.g. order 4~bytes) lead to unacceptably high
protocol overheads for large (order 1~kB+) messages. An upper bound on
packet-length leads to possibly complex software-level fragmentation schemes
(or worse hardware-level if the bus packet length $<$ message buffer).

A leading length field with a reasonably large upper bound would then be
acceptable, although not ideal. The goal is to allow for true arbitrary length
packets if possible.

\paragraph{Consider automatic address space management protocol?}
There is an extensibility / simplicity trade-off. I2C only allowed for 128
addresses, which for an individual bus instance was seen as more than enough
(still pretty true with the loading requirements, but repeaters / extenders
make that less true). The real issue though is address space collisions
between generic components. To build a plug 'n play bus of any arbitrary
pieces requires the whole corpus of parts to have non-conflicting addresses.
This motivates extensibility.

Addressing has not yet been defined. It would be interesting to do the math
and see what percentage of addresses a lost to a scheme such as `no legal
address ends in 00', allowing easy, endless extensibility, but at XX\% cost?

\paragraph{Allow interposing of the bus to read out / insert data from
external source}
Sniffing pretty much any bus design is easy, but adding devices post-hoc is a
harder requirement. There is great motivation for transient connection of
devices (programmer, debugger, etc), and also some motivation for the ability
to permanently add new devices to an existing bus.

A reasonable argument for the permanent addition is that the addition /
removal is so infrequent that it can be an intrusive process; unless something
like a pre-packaged IC had a \bus internally and there was desire to allow the
possible addition of external components? In that case though, why not simply
use a separate bus, or leverage the same mechanism as...

Transient additions to the bus are much less negotiable. It's not immediately
obvious if there are examples beyond a programmer / debugger, but those two
are sufficiently critical as to motivate the need for some kind of external
transient device.

\paragraph{Must be uni-directional}
Bi-Directional analog hardware is complex and not synthesizable.

\paragraph{Endianness}
\subparagraph{Byte-Level}
No specific design consideration here per se. Given that \bus supports
messages of an arbitrary length, it simply felt more logical to send bytes
from 0{\ldots}N instead of N{\ldots}0.
\subparagraph{Bit-Level}
Again an arbitrary decision. The first test implementation elected to use MSB
and the decision was made.

\paragraph{Retransmission}
Hardware retransmission carries risks of accidentally locking up the bus,
endlessly retransmitting. While ideas such as a maximum retry count (SMBus)
mitigate this, the added complexity and risk of a hardware retransmission tip
the scales in favor of pushing the retransmission decisions to software.

To provide the software layer with more information, we choose to require the
indication of the number of bytes actually transmitted. While transient faults
could certainly occur, it is reasonable that the software can infer different
{\em probable} causes from the amount of the message that was transmitted.

\paragraph{Flow Control}
Any form of flow control requires communication {\em mid-transmission} between
the transmitting and receiving node. This could be accomplished by
periodically (e.g. every word) switching roles, but this introduces a large
amount of complexity. Another solution is an open-collector style bus (e.g.
I2C), but such designs were ruled out previously for power and
synthesizability considerations.

Our resulting selection trades simplicity for efficiency w.r.t.\ flow control.
If a receiving node's RX buffer is overrun, it may (but is not required to)
issue a Bus~Reset. Otherwise an entire message must be transmitted before any
indication of failure or success is indicated.

In practice, transmitting nodes should consider sending some form of {\em
ping} message to a destination node to validate its presence before sending a
large transmission to minimize waste if the destination node is not actually
present. \bus is not designed for a changing topology, as such discovery of
this nature need only be performed once and the amortized cost is considered
negligible.

\paragraph{Acknowledgement granularity}
As \bus supports messages of arbitrary length, a natural question arises for
the granularity of acknowledgements. At one extreme, designs such as I2C elect
to acknowledge every byte. \bus takes the opposite approach, providing only a
single acknowledgement at the end of a transmission in an all-or-nothing
fashion. The rationale for this decision again returns to simplicity and
efficiency in design. While a receiver-driven acknowledgement cycle could
easily be added every \nth{33} bit, the relative merits of this are not great.
Assuming a receiver exists on the bus, by not electing to issue a Bus~Rest, a
receiver implicitly ACKs every bit sent. A receiver that has occasion to NAK a
transmission may do so at any time during transmission. Transient faults, e.g.
a missed clock edge, will cause the node to fall into reset
(see~\ref{sec:design-reset}), in which case the message will not be ACK'd---a
single data-bit error would require a node to miss four consecutive clock
edges, which is considered extremely unlikely. The remaining consideration
then is the absent receiver, which is a relative non-issue for a bus such as
\bus with a static topology.

\paragraph{Streaming}
Some bus designs incorporate a ``streaming'' mode, which allows for a series
of physical bus transactions to be considered one continguous message at the
receiving layer. As \bus allows for arbitrary length messages, such a feature
becomes largely unnecessary, and \bus defines no streaming primative.

\paragraph{Avoid ratioed-logic, avoid timing constraints}

\paragraph{Idle State Should Be High}
We probably don't have to mention this, but it's important that they are high
since we can pull down a node with minimum power consumption (vs pulling a
node high). When a node pulls low, the pmu is still in standby mode so,
there's not much power.  I'm not sure if we want to get into the power budgets
of the nodes in different modes - it will depend on the pmu design...

\paragraph{Consider Arbitration as DOUT and CLK low?}
One more note on this time:  currently, the spec requires that the pmu resides
with the ctr processor, since it's the only node that is definitely aware of a
wakeup.  However, if the ctr instead pulls down right way on clk (not data),
which does not take much power, then all nodes will know that a bus request
has been detected and the pmu can reside on any node.  The ctr that would have
to delay before raising the clk to allow the pmu to switch mode etc...

\subsection{Reset Design}
\label{sec:design-reset}
The reset mechanism is the \bus escape hatch. Its reliability is a first
order design constraint, and here we attempt to demonstrate how the reset
mechanism can in all possible states reliably reset \bus. Some other possible
reset designs and their shortcomings are discussed in
Appendix~\ref{sec:appendix-reset}.
\begin{quote}
\em n.b.\ this section assumes a knowledge of \bus design
\end{quote}

We first examine when a transaction occurs correctly, as designed, and then
consider various failure modes.

\subsubsection{An Ideal Transmission}
~

\begin{figure}[!h]
    \hspace{-4em}
\begin{subfigure}{\textwidth}
    \scriptsize
    \begin{tikztimingtable}[timing/slope=.3]
      %       |   D1    | D0  | D1  |     MES       |
      Din  & L 1.4L8{2H} 8{2L} 8{2H} 4{2H}3{2L}0.6L L \\
      Dout & L 0.0L8{2H} 8{2L} 8{2H} 4{2H}3{2L}2.0L L \\
      \\
      Din  & L 0.2L8{2H} 8{2L} 8{2H} 4{2H}3{2L}1.8L L \\
      Dout & L 0.4L8{2H} 8{2L} 8{2H} 4{2H}3{2L}1.6L L \\
      \\
      Din  & L 0.6L8{2H} 8{2L} 8{2H} 4{2H}3{2L}1.4L L \\
      Dout & L 0.8L8{2H} 8{2L} 8{2H} 4{2H}3{2L}1.2L L \\
      \\
      Din  & L 1.0L8{2H} 8{2L} 8{2H} 4{2H}3{2L}1.0L L \\
      Dout & L 1.2L8{2H} 8{2L} 8{2H} 4{2H}3{2L}0.8L L \\
      CLK  & C 32{2C}                               C \\
           & \\
      \extracode
        \begin{pgfonlayer}{background}
          \begin{scope}[semitransparent,semithick]
            \vertlines{1,17,...,\twidth}
          \end{scope}
          \begin{scope}[semitransparent,semithick,dashed]
            \vertlines{9,25,...,\twidth}
          \end{scope}
          \begin{scope}[semitransparent,semithick,dashed,color=red]
            \vertlines{5,13,...,\twidth}
          \end{scope}
          \begin{scope}[semitransparent]
            % TX
            \filldraw[yellow] ( 1,-0.5)  rectangle ( 5,-2.5);
            \filldraw[yellow] (17,-0.5)  rectangle (21,-2.5);
            \filldraw[yellow] (33,-0.5)  rectangle (37,-2.5);
            \filldraw[yellow] (49,-0.5)  rectangle (53,-2.5);
            \filldraw[yellow] (57,-0.5)  rectangle (61,-2.5);
            % RX
            \filldraw[yellow] (65,-6.5)  rectangle (66,-8.5);
            % Clk
            \filldraw[yellow] ( 0,-20.5) rectangle (\twidth,-22.5);
          \end{scope}
        \end{pgfonlayer}
        \begin{scope}
          [font=\sffamily\small,shift={(-3.0em,-0.5)},anchor=east,color=blue]
          \node at (  0,   0) {TX};
          \node at (  0,  -6) {RX};
          \node at (  0, -12) {Fwd};
          \node at (  0, -19) {Ctl};
        \end{scope}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=brown]
          \pgfmathparse{\twidth-16}
          \foreach \x [evaluate=\x] in {1,17,...,\pgfmathresult}
            \foreach \offset/\l in {0/Drive1,4/Latch1,8/Drive2,12/Latch2}
              \node [rotate=45] at (\x+\offset,0) {\l};
          \pgfmathparse{\twidth-1}
          \node[rotate=45] at (\pgfmathresult,0) {Drive1};
        \end{scope}
        \begin{scope}
          [font=\small,anchor=south,shift={(1,-18em)}]
          \draw
            (0,0) node[] (a) {}
            (16,0) node[] (c) {}
            (32,0) node[] (e) {}
            (48,0) node[] (g) {}
            (64,0) node[] (i) {}
            (66,0) node[] (z) {\ldots};
          \node[right=2 of a] (b) {Data 1 (11)};
          \node[right=2 of c] (d) {Data 0 (00)};
          \node[right=2 of e] (f) {Data 1 (11)};
          \node[right=3 of g] (h) {MES (10)};
          \draw[->] (b.west) -- (a.east);
          \draw[<-] (c.west) -- (b.east);
          \draw[->] (d.west) -- (c.east);
          \draw[<-] (e.west) -- (d.east);
          \draw[->] (f.west) -- (e.east);
          \draw[<-] (g.west) -- (f.east);
          \draw[->] (h.west) -- (g.east);
          \draw[<-] (i.west) -- (h.east);
        \end{scope}
    \end{tikztimingtable}

    \begin{tikztimingtable}[timing/slope=.3]
      %       | ACK 0      1     1     0      |ACK/RST 0  1   | RST 0 11
      Din  & L 1.0L4{2L} 4{2H} 4{2H} 3{2L}1.0L 0.2L8{2L} 8{2H}  8{2L} 7{2H} 1.8H H \\
      Dout & L 1.2L4{2L} 4{2H} 4{2H} 3{2L}0.8L 0.4L8{2L} 8{2H}  8{2L} 7{2H} 1.6H H \\
      \\
      Din  & L 1.4L4{2L} 4{2H} 4{2H} 3{2L}0.6L 0.6L8{2L} 8{2H}  8{2L} 7{2H} 1.4H H \\
      Dout & L 0.0L4{2L} 4{2H} 4{2H} 3{2L}2.0L 0.8L8{2L} 8{2H}  8{2L} 7{2H} 1.2H H \\
      \\
      Din  & L 0.2L4{2L} 4{2H} 4{2H} 3{2L}1.8L 1.0L8{2L} 8{2H}  8{2L} 7{2H} 1.0H H \\
      Dout & L 0.4L4{2L} 4{2H} 4{2H} 3{2L}1.6L 1.2L8{2L} 8{2H}  8{2L} 7{2H} 0.8H H \\
      \\
      Din  & L 0.6L4{2L} 4{2H} 4{2H} 3{2L}1.4L 1.4L8{2L} 8{2H}  8{2L} 7{2H} 0.6H H \\
      Dout & L 0.8L4{2L} 4{2H} 4{2H} 3{2L}1.2L 0.0L8{2L} 8{2H}  8{2L} 7{2H} 2.0H H \\
      CLK  & C     4{2C} 4{2C} 4{2C} 4{2C}       4L3{4C} 4{4C}  4{4C} 4{4C}      H \\
      ~~~  & C     4{2C} 4{2C} 4{2C} 4{2C}         8{2C} 8{2C}  8{2C} 8{2C}      C \\
      \extracode
        \begin{pgfonlayer}{background}
          \begin{scope}[semitransparent,semithick]
            \vertlines{1,17,...,32}
            \pgfmathparse{\twidth-1}
            \vertlines{\pgfmathresult}
          \end{scope}
          \begin{scope}[semitransparent,semithick,dashed]
            \vertlines{9,25,...,48}
            \vertlines{53,69}
          \end{scope}
          \begin{scope}[semitransparent,semithick,dashed,color=red]
            \vertlines{5,13,...,48}
            \vertlines{61,77}
            \vertlines{85,93}
          \end{scope}
          \begin{scope}[semitransparent,semithick,color=blue]
            \pgfmathparse{\twidth-17}
            \vertlines{33,49,...,\pgfmathresult}
          \end{scope}
          \begin{scope}[semitransparent,semithick,dashed,color=blue]
            \vertlines{57,73,...,\twidth}
          \end{scope}
          \begin{scope}[semitransparent,yellow]
            % TX
            %\filldraw[yellow] ( 0,-0.5)  rectangle (1,-2.5);
            % RX
            \filldraw ( 1,-6.5)  rectangle ( 5,-8.5);
            \filldraw ( 9,-6.5)  rectangle (13,-8.5);
            \filldraw (17,-6.5)  rectangle (21,-8.5);
            \filldraw (25,-6.5)  rectangle (29,-8.5);
            % Clk
            \filldraw ( 0,-20.5) rectangle (33,-22.5);
          \end{scope}
          \begin{scope}[cyan,opacity=.25]
            \filldraw   (33,-18.5) rectangle (\twidth-1,-22.5);
          \end{scope}
        \end{pgfonlayer}
        \begin{scope}
          [font=\sffamily\small,shift={(-3.0em,-0.5)},anchor=east,color=blue]
          \node at (  0,   0) {TX};
          \node at (  0,  -6) {RX};
          \node at (  0, -12) {Fwd};
          \node at (  0, -19) {Ctl};
        \end{scope}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=brown]
          \foreach \x [evaluate=\x] in {1,17,...,29}
            \foreach \offset/\l in {0/Drive1,4/Latch1,8/Drive2,12/Latch2}
              \node [rotate=45] at (\x+\offset,0) {\l};
          \def\base{37}
          \node [rotate=45] at (\base+0, 0) {Drive1};
          \node [rotate=45] at (\base+8, 0) {Latch1};
          \node [rotate=45] at (\base+16, 0) {Drive2};
          \node [rotate=45] at (\base+24, 0) {Latch2};
          \node [rotate=45] at (\base+32, 0) {Drive1};
          \node [rotate=45] at (\base+40, 0) {Latch1};
          \node [rotate=45] at (\base+48, 0) {Reset};
          \node [rotate=45] at (\base+56, 0) {Reset};
        \end{scope}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=blue]
          \def\base{33}
          \node [rotate=45] at (\base+0, 0) {R0-D};
          \node [rotate=45] at (\base+8, 0) {R0-L};
          \node [rotate=45] at (\base+16, 0) {R1-D};
          \node [rotate=45] at (\base+24, 0) {R1-L};
          \node [rotate=45] at (\base+32, 0) {R0-D};
          \node [rotate=45] at (\base+40, 0) {R0-L};
          \node [rotate=45] at (\base+48, 0) {R1-I1};
          \node [rotate=45] at (\base+56, 0) {R1-I1};
          \node [color=black] at (\base+64, 0) {Idle};
        \end{scope}
        \begin{scope}
          [font=\small,anchor=south,shift={(1,-18em)}]
          \draw
            (-2,0) node[] (z) {\ldots}
            (0,0) node[] (a) {}
            (64,0) node[] (c) {};
          \node[right=16 of a] (b) {Acknowledgement (01,10,01)};
          \draw[->] (b.west) -- (a.east);
          \draw[<-] (c.west) -- (b.east);
        \end{scope}
        \begin{scope}
          [font=\small,anchor=south,shift={(1,-19.5em)}]
          \draw
            (32,0) node[] (c) {}
            (\twidth-2,0) node[] (e) {};
          \node[right=12 of c] (d) {Reset (010..11)};
          \draw[->] (d.west) -- (c.east);
          \draw[<-] (e.west) -- (d.east);
        \end{scope}
    \end{tikztimingtable}
\end{subfigure}
  \label{fig:reset-normal}
%}
  \caption{A normal end sequence, showing the last three bits sent (1, 0, 1)
followed by a Message~End~Sequence and Message~Acknowledgement. During reset,
the control node halves the clock speed it puts on the bus for phase-locking.
Here we see the accelerated Reset, which can hopefully be safely entered\ldots
}
\end{figure}

\subsubsection{Phase Offsets}
At some point, it is possible that a node may miss a clock edge. At that
point, the node is considered out of phase. In order for the node to
successfully communicate in the future, it is necessary for the node to
re-align. We leverage the reset sequence to achieve this goal, and also
include a brief discussion of the implications of whether the node that falls
out of phase is a forwarding, transmitting, or receiving node.

For the purposes of phase, the control node is defined to always be in phase.
If a local clock glitch somehow occurs on the control node, then the entire
bus is considered out of phase from the control node and the control node will
reset the bus when it detects another node is out of phase.

In all $1\phi$ and $3\phi$ cases, the latched values are non-deterministic as
the node is sampling for its local {\sc latch1/latch2} cycle while the transmitting
node is driving the new bit. Most likely the node will latch the value that
was previously on the bus as the new bit will not have propagated to the local
{\tt DIN}. It is possible, however, that the node that is transmitting has a
lower threshold for detecting the rise of {\tt CLK} and a powerful {\tt DOUT}
driver, in which case the out-of-phase node will latch the new value.

Transmitting the same bit twice in a row is uninteresting as there are no
changes on the data lines. We examine then: TX~1$\rightarrow$0,
TX~0$\rightarrow$1, TX~1$\rightarrow$Message~End~Sequence,
the~Message~End~Sequence,
Message~End~Sequence$\rightarrow$Message~Acknowledgement,
Message~Acknowledgement$\rightarrow$Idle.

\medskip
\noindent
\begin{framed}
  \label{reset-assumption}
  \textbf{One Critical Assumption:} When nodes are $1\phi$ or $3\phi$ out of
  phase, for any member node it is non-deterministic if the new data or the
  rising clock arrives first. For the {\em control} layer, however, we must
  be able to assume that the control layer will sample its {\tt DIN} as it
  raises the {\tt CLK} line, that is {\em before} a new value could possibly
  have propogated.  This is necessary to resolve issues such as those discussed
  in $1\phi-$TX$-0\rightarrow$1~(\ref{reset-phi1-tx-0-1}).
\end{framed}

\medskip
\textbf{\textsc{Todo:}} The sample graphics do not include
TX~0$\rightarrow$~Message~End~Sequence, Message~End~Sequence$\rightarrow$Idle,
others? Does that matter?

\paragraph{$1\phi$ Offset}
~

\begin{quote}
{\em Note:} A transmitting node that is $1\phi$ off is equivalent to the rest
of the bus being $3\phi$ off, and thus need not be explicitly discussed here.
\end{quote}

A node that has missed one clock edge will be one phase behind:

\begin{figure}[!h]
\noindent\makebox[\textwidth]{%
    \tiny
    \begin{tikztimingtable}[timing/slope=.3]
      %       |  D0   |  D1   |  D0   |  D1   |    MES        |
      %       |   ACK   01   ,  10          | ACK/RST 01   | 0 Reset 11
      Din  & L 8{1.5L} 8{1.5H} 8{1.5L} 8{1.5H} 4{1.5H} 4{1.5L}
               4{1.5L}4{1.5H} 4{1.5H}4{1.5L} 8{1.5L}8{1.5H} 8{1.5L}6{1.5H} H \\
      CLK  & C 8{1.5C} 8{1.5C} 8{1.5C} 8{1.5C} 4{1.5C} 4{1.5C}
               4{1.5C}4{1.5C} 4{1.5C}4{1.5C} 3L3{3C}  4{3C}   4{3C}  3{3C} C \\
      Bus  & D{}{12D{Data 0}}{12D{Data 1}}{12D{Data 0}}{12D{Data 1}}{12D{MES 10}}
               {12D{ACK 01}}{12D{ACK 10}}{24D{ACK/RST 01}} {21D{0 Reset 11}}D \\
      \extracode
        \begin{pgfonlayer}{background}
          \begin{scope}[semitransparent,semithick,dashed,color=red]
            \vertlines{1,7,...,83}
            \vertlines{88,100,112,118,124}
          \end{scope}
          \begin{scope}[semitransparent,semithick,dashed]
            \vertlines{4,10,...,87}
            \vertlines{94,106,130}
          \end{scope}
          \begin{scope}[cyan,opacity=.25]
            % Reset
            \filldraw  (85,-.5) rectangle (\twidth-1,-2.5);
          \end{scope}
          \foreach \n [evaluate=\n as \l using int((\n-1)/3)] in {1,4,...,\twidth}
            \draw (\n,-5) -- +(0,-.2)
              node [below,inner sep=2pt] {\scalebox{.75}{\tiny\l}};
        \end{pgfonlayer}
        \begin{scope}
          [font=\sc\tiny,anchor=north,shift={(0,3em)},color=red]
          \foreach \x [evaluate=\x] in {1,13,...,79}
            \foreach \offset/\l in {0/Latch2,3/Drive1,6/Latch1,9/Drive2}
              \node [rotate=45] at (\x+\offset,0) {\l};
          \node [rotate=45] at (88,0) {Latch2};
          \node [rotate=45] at (94,0) {Drive1};
          \node [rotate=45] at (100,0) {Latch1};
          \node [rotate=45] at (106,0) {Drive2};
          \node [rotate=45] at (112,0) {Latch2};
          \node [rotate=45] at (118,0) {Reset (D)};
          \node [rotate=45] at (124,0) {Reset (L)};
          \node [rotate=45,color=black] at (130,0) {Idle (L)};
        \end{scope}
    \end{tikztimingtable}
}
\caption{A nominal transmission (0, 1, 0, 1, MES, ACK, Reset) labeling the
states as $1\phi$ behind. The {\tt CLK} and {\tt Bus} lines reflect the actual
bus values, not those as interpreted by the $1\phi$ behind node.
}
\label{fig:1-phi}
\end{figure}

\subparagraph{Forwarding Nodes}
There is not much attention paid to forwarding nodes in these breakdowns, as
the only concern is a forwarding node inadvertantly entering Reset and
progressing all the way to idle. A forwarding node can pre-emptively enter
Reset in two possible cases:

\begin{itemize}
  \item {\bf 0$\rightarrow$1$\rightarrow$0:} Referring to local $1\phi$
states, the node would have to {\sc latch2} a~0 from Data bit~0 as data is
rising, then it will unconditionally {\sc latch1} a~1 during the global {\sc
drive2} as data is stable, and finally it must {\sc latch2} a~0 as data is
falling. At this time the node is sampling {\em every} edge, but the next
three global edges are {\sc latch1}, {\sc drive2}, {\sc latch2} which will all
be {\tt 0}. The Reset engine will not observe {\tt 11} or {\tt 011} and the
node will return to forwarding.

  \item {\bf 0$\rightarrow$MES$\rightarrow$ACK:} Referring to times in
Figure~\ref{fig:1-phi} for clarity, the {\tt 010} sequence would be latched at
times 16 (from the Data 0), 18, and 20. Now the node is latching every edge,
but it is possible to latch {\tt 011} during times 21, 22, and 23 and falsely
enter into Idle. For this to occur, however, the lagging node would have to
have latched the previous value on the bus during both a 0$\rightarrow$1
transition (time~16) and a 1$\rightarrow$0 transition (time~18), but then at
time~22 it would have to latch the new value during a 0$\rightarrow$1
transition. \hl{TODO: I am considering this sufficiently improbable?}
  \label{todo:varying-latches}
\end{itemize}

\subparagraph{TX 1$\rightarrow$0}
In the common case, the node will latch another 1, matching the {\sc latch1}
value, deferring the issue to another possible state. If the node does catch
the new 0, it will detect 

\subparagraph{TX 0$\rightarrow$1}
\label{reset-phi1-tx-0-1}
For most nodes, this is the complement of TX~1$\rightarrow$0. However, if the
node happens to be a receiving node it will detect this as the beginning of a
Message~End~Sequence ({\tt 0111}). Figure~\ref{fig:reset-1phi-tx-0-1} details
the possible outcomes of a TX~0$\rightarrow$1 glitch.  Note the controller's
detection relies on the reset assumption~(\ref{reset-assumption}) to detect
the issue.

\subparagraph{TX 1$\rightarrow$Message End Sequence}
Latching an extra {\tt 1} and missing the {\tt 0} will result either in a {\tt
11} sequence and eventually no acknowledgement, a {\tt 10} sequence---a
reset---, or a half-cycle lagged {\tt 01} sequence. This final case we examine
in detail in Figure~\ref{fig:1-phi-tx1mes}.

\subparagraph{TX 0$\rightarrow$Message End Sequence}
Slipping an edge here will either cause the node to read the 0 from the
Message~End~Sequence as the completion of the 0 bit, or to miss the first 0 of
the Message~End~Sequence completely, reading an extra 1 bit in place of it. In
the former case, the transmission completes normally. In the latter, an
additional high bit will be read, after which the failure of the RX layer to
ACK will cause the control layer to reset the bus, discarding the transaction.

\subparagraph{Message End Sequence}

\subparagraph{Message End Sequence$\rightarrow$Message Acknowledgement}

\subparagraph{Message Acknowledgement}

\subparagraph{Message Acknowledgement$\rightarrow$Reset Sequence}


