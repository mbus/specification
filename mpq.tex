\section{\proto: Point-to-Point Message Protocol}
\bus also defines a common point-to-point messaging protocol: \proto.
%For those chips kind enough to mind their P's and Q's on MBus
Nodes are not required to support \proto to be \bus compliant, however it is
strongly encouraged.

\proto defines two classes of data: register data and memory data. \proto
registers have 8~bit addresses and are 24~bits wide. \proto memory has 32~bit
addresses and stores data that is 32~bits wide. The register address space and
memory address space are separate constructs, that is register address {\tt
0x00} need not map to memory address {\tt 0x00000000}, although aliasing is
permitted.

\subsection{\proto Registers (Reg \#192--255)}
\label{cmd:conf}
\proto reserves the top 64~registers for control and configuration. This space
configures various \proto capabilities. Much of the space is currently
reserved for future expansion.

Attempts to write configuration for unsupported features (e.g.\ configuration
of a memory streaming channel on a device with no memory) is undefined.
Attempts to read unsupported features {\bf must} NAK or return all {\tt 0}.

This section documents each of the registers. The top two bits of each
register address are \hlc[lightgreen]{\texttt{11}} followed by six bits that
identify the \hlc[lightergreen]{command type}. All \hlc[lightgray]{reserved}
bits should be treated as RZWI.

\subsubsection{Reserved Registers}
All registers not specified here are reserved.
Writes to reserved registers should be ignored. Reads from reserved registers
should return all {\tt 0}.


\subsubsection{Reg \#224--239: Memory Stream Configuration}
\label{cmd:conf-memory-stream}

\begin{bytefield}{8}
  \bitheader{0-7} \\
  \colorbitbox{lightgreen}{2}{11}
  \colorbitbox{lightergreen}{2}{10}
  \colorbitbox{lightcyan}{2}{XX}
  \colorbitbox{lightergreen}{2}{00}
\end{bytefield}
~
\begin{bytefield}{24}
  \bitheader{0-23} \\
  \bitbox{8}{\scriptsize Alert Address}
  \bitbox{14}{Write Buffer [15:2]}
  \colorbitbox{lightgray}{1}{\begin{sideways}{\tiny RSV}\end{sideways}}
  \colorbitbox{lightgray}{1}{\begin{sideways}{\tiny RSV}\end{sideways}}
\end{bytefield}
\hfill\textbf{Default: \texttt{0x000000}}
\\

\noindent
\begin{bytefield}{8}
  \bitheader{0-7} \\
  \colorbitbox{lightgreen}{2}{11}
  \colorbitbox{lightergreen}{2}{10}
  \colorbitbox{lightcyan}{2}{XX}
  \colorbitbox{lightergreen}{2}{01}
\end{bytefield}
~
\begin{bytefield}{24}
  \bitheader{0-23} \\
  \colorbitbox{lightgray}{8}{\scriptsize Reserved}
  \bitbox{16}{Write Buffer [31:16]}
\end{bytefield}
\hfill\textbf{Default: \texttt{0x000000}}
\\

\noindent
\begin{bytefield}{8}
  \bitheader{0-7} \\
  \colorbitbox{lightgreen}{2}{11}
  \colorbitbox{lightergreen}{2}{10}
  \colorbitbox{lightcyan}{2}{XX}
  \colorbitbox{lightergreen}{2}{10}
\end{bytefield}
~
\begin{bytefield}{24}
  \bitheader{0-23} \\
  \bitbox{1}{\begin{sideways}{\tiny EN}\end{sideways}}
  \bitbox{1}{\begin{sideways}{\tiny WRP}\end{sideways}}
  \bitbox{1}{\begin{sideways}{\tiny DBLB}\end{sideways}}
  \colorbitbox{lightgray}{1}{\begin{sideways}{\tiny RSV}\end{sideways}}
  \bitbox{20}{Buffer Length-1}
\end{bytefield}
\hfill\textbf{Default: \texttt{0x000000}}
\\

\noindent
\begin{bytefield}{8}
  \bitheader{0-7} \\
  \colorbitbox{lightgreen}{2}{11}
  \colorbitbox{lightergreen}{2}{10}
  \colorbitbox{lightcyan}{2}{XX}
  \colorbitbox{lightergreen}{2}{11}
\end{bytefield}
~
\begin{bytefield}{24}
  \bitheader{0-23} \\
  \colorbitbox{lightgray}{4}{\scriptsize Reserved}
  \bitbox{20}{Buffer Offset}
\end{bytefield}
\hfill\textbf{Default: \texttt{0x000000}}
\\

In \proto each node has up to four independent, identical memory streaming
\hlc[lightcyan]{channels}. Each channel has two configuration registers. The
two registers work together to configure each channel.

\begin{itemize}
  \item {\tt \{R01[15:0], R00[15:2], 2'b00\}: Write Buffer.}
    \subitem Pointer to the beginning of a buffer in memory.
  \item {\tt \{R00[23:16]\}: Alert Address.}
    \subitem Defines alerts are sent. If the alert prefix (bits 23:20) are set
    to the full-prefix indicator {\tt 1111}, the alert is suppressed.
    \subitem Alerts are sent whenever the end of the buffer is reached.  If
    {\tt DBLB} is active, an alert is also sent when the halfway point of the
    buffer is reached.
    \subitem \hl{TODO NEXT: Solidfy Alert Message.}
  \item {\tt \{R10[19:0]\}: Buffer Length-1.}
    \subitem Defines the length of the buffer.
  \item {\tt \{R10[23]\}: Enable (EN).}
    \subitem Controls whether this channel is enabled. If {\tt EN} is {\tt 0},
    a node must not modify memory in response to a memory stream message.%
    \footnote{
      Implementation Tip: Any undefined \proto registers are defined to be
      RZWI, that is a read from an undefined register will read as all 0's
      (and a write ignored). Upon a read, this will return {\tt 0} for {\tt
      EN} as required.  Nodes that do not implement a memory stream channel do
      not require any logic to handle any memory stream messages, simply leave
      the register undefined.
    }
    \subitem {\bf Acknowledement/Interjection:} The behavior of a stream write
    when {\tt EN} is {\tt 0} is undefined. Receivers are encouraged to
    interject and indicate receiver error, however they may exhibit any
    behavior, including ACK'ing the transaction and silently ignoring it.
    {\em This behavior is subject to change in future revisions of \proto.}
  \item {\tt \{R10[22]\}: Wrap (WRP).}
    \subitem Defines node behavior when the end of the buffer is reached. If
    {\tt WRP} is high, the {\tt Write Address Counter} should reset to its
    original value. If {\tt WRP} is low, the {\tt Write Address Counter} value
    should be unchanged (it should thus be one past the end of the valid
    buffer) and {\tt EN} should be set to {\tt 0}.
  \item {\tt \{R10[21]\}: Double Buffer (DBLB).}
    \subitem Controls double-buffering mode. If double-buffering is active,
    the node should generate an alert halfway through the buffer in addition
    to at the end of the buffer. This mode is most useful when combined with
    {\tt WRP}.
\end{itemize}

\subsubsection{Reg \#240: Register Message Control}
\label{cmd:conf-reg-ctrl}

\begin{bytefield}{8}
  \bitheader{0-7} \\
  \colorbitbox{lightgreen}{2}{11}
  \colorbitbox{lightergreen}{6}{110000}
\end{bytefield}
~
\begin{bytefield}{24}
  \bitheader{0-23} \\
  \bitbox{1}{\begin{sideways}{\tiny EN}\end{sideways}}
  \colorbitbox{lightgray}{23}{Reserved}
\end{bytefield}
\hfill\textbf{Default: \texttt{0x800000}}
\\

\begin{itemize}
  \item {\tt \{R[23]\}: Enable (EN).}
    \subitem Controls whether register writes to this device are enabled. If
    {\tt EN} is {\tt 0}, attempts to write registers~\#0--247 are silently
    ignored.
    \subitem {\bf Note:} Registers~\#248--255 ({\tt b'11111XXX}) can always be
    written.
    \subitem {\bf Acknowledement/Interjection:} Since a single register write
    transaction could write both enabled and disabled registers, a node should
    not interject when a disabled register is written. A node should ACK to
    indicate that the transmission was received successfully, even if nothing
    is actually written.
    {\em This behavior is subject to change in future revisions of \proto.}
    \subitem {\color{red} \bf Warning:} If {\tt EN} is disabled, it cannot be
    re-enabled by a write to this register since register writes are disabled.
    Access can be recovered using \nameref{cmd:conf-reg-reset}, however this
    will reset all registers.
    \subitem \hl{TODO} What about a local write (e.g. a register write via an
    interrupt from the CPU)? Should probably always allow those. Does that
    make sense as an exception?
\end{itemize}

\subsubsection{Reg \#242: Bulk Memory Message Control}
\label{cmd:conf-mem-ctrl}

\begin{bytefield}{8}
  \bitheader{0-7} \\
  \colorbitbox{lightgreen}{2}{11}
  \colorbitbox{lightergreen}{6}{110010}
\end{bytefield}
~
\begin{bytefield}{24}
  \bitheader{0-23} \\
  \bitbox{1}{\begin{sideways}{\tiny EN}\end{sideways}}
  \bitbox{1}{\begin{sideways}{\tiny CACT}\end{sideways}}
  \colorbitbox{lightgray}{1}{\begin{sideways}{\tiny RSV}\end{sideways}}
  \colorbitbox{lightgray}{1}{\begin{sideways}{\tiny RSV}\end{sideways}}
  \bitbox{20}{Length Limit-1}
\end{bytefield}
\hfill\textbf{Def: \texttt{0x800000}}, \texttt{0x000000} if no mem
\\

The register controls the response of this chip upon the receipt of a
\nameref{cmd:mem-bulk-write} command.

\begin{itemize}
  \item {\tt \{R[23]\}: Enable (EN).}
    \subitem Controls whether bulk memory transactions written to this device
    are enabled. If {\tt EN} is {\tt 0}, a node must not modify the contents
    of memory in response to a bulk memory transaction.
    \subitem {\bf Acknowledement/Interjection:} The behavior of a bulk write
    when {\tt EN} is {\tt 0} is undefined. Receivers are encouraged to
    interject and indicate receiver error, however they may exhibit any
    behavior, including ACK'ing the transaction and silently ignoring it.
    {\em This behavior is subject to change in future revisions of \proto.}
  \item {\tt \{R[22]\}: Control Active (CACT).}
    \subitem If this bit is high, this register's length field acts as a limit
    for the maximum permitted bulk message length. A bulk message is allowed
    to write until this message limit is reached. If more data comes, the
    message {\bf must} be NAK'd. The receiver should interject with receiver
    error as soon as it knows the length limit has been exceeded.
  \item {\tt \{R[19:0]\}: Length Limit.}
    \subitem The maximum permitted length in words of a memory bulk write
    message to any address.
\end{itemize}


\subsubsection{Reg \#254: Alert}
\label{cmd:conf-alert}

\begin{bytefield}{8}
  \bitheader{0-7} \\
  \colorbitbox{lightgreen}{2}{11}
  \colorbitbox{lightergreen}{6}{111110}
\end{bytefield}
~
\begin{bytefield}{24}
  \bitheader{0-23} \\
  \bitbox{24}{Alert Payload}
\end{bytefield}
\hfill\textbf{Default: \texttt{0x000000}}
\\

This register is written whenever another node wishes to send an alert. The
alert payload format is specified by the type of alert. For most alerts, the
top 8~bits specify the address of the node and functional unit that generated
the alert.

All alerts share the same register. Multiple back-to-back alert messages are
permitted. Implementations should either handle alerts faster than the bus
speed or copy alerts to a local queue.

\subsubsection{Reg \#255: Action Register}
\label{cmd:conf-reg-reset}

\begin{bytefield}{8}
  \bitheader{0-7} \\
  \colorbitbox{lightgreen}{2}{11}
  \colorbitbox{lightergreen}{6}{111111}
\end{bytefield}
~
\begin{bytefield}{24}
  \bitheader{0-23} \\
  \bitbox{1}{\begin{sideways}{\tiny RST}\end{sideways}}
  \colorbitbox{lightgray}{3}{RSV}
  \bitbox{1}{\begin{sideways}{\tiny RSTR}\end{sideways}}
  \bitbox{1}{\begin{sideways}{\tiny RSTB}\end{sideways}}
  \bitbox{1}{\begin{sideways}{\tiny RSTS}\end{sideways}}
  \colorbitbox{lightgray}{17}{Reserved}
\end{bytefield}
\hfill\textbf{$<$No Storage$>$}
\\

This register requests that an action be performed. It is an error to request
more than one action in a single request. Actions are processed from MSB to
LSB, that is, if more than one action is requested {\em only} the highest
priority action is actually taken.

A read from this register shall always return all {\tt 0}.

A write of all {\tt 0} to this register shall perform no actions.

If any bit written to this register is non-zero, writing this register {\bf
must} be the last operation in the transaction. The behavoir of anything after
a register action request in the same transaction is undefined.

\begin{itemize}
  \item \texttt{\{R[23]\}: Reset (RST).}
    \subitem Reset the entire node. The exact result of a reset is
    implementation-defined, however this request should be the most aggresive
    form of reset available.
  \item \texttt{\{R[19]\}: Reset Register Registers (RSTR).}
    \subitem Reset \proto configuration registers that affect register
    protocol behavior to their default value.
    \subitem Resets \#240.
  \item \texttt{\{R[18]\}: Reset Bulk Registers (RSTB).}
    \subitem Reset \proto configuration registers that affect memory bulk
    transfers to their default value.
    \subitem Resets \#242.
  \item \texttt{\{R[17]\}: Reset Stream Registers (RSTS).}
    \subitem Reset \proto configuration registers that affect memory stream
    transfers to their default value.
    \subitem Resets \#224--239.
\end{itemize}

\subsection{Register Commands}
\label{cmd:reg}
\proto register space is an 8~bit addressable array of 24~bit wide registers.
Any undefined bits are treated as RZWI (Read as Zero, Write Ignored).

\subsubsection{Register Write}
\label{cmd:reg-write}

\begin{bytefield}{9}
  \bitheader{0-7} \\
  \bitbox[rbt]{5}{{\dots}Prefix}
  \bitbox{4}{0000} \\
  \bitbox[t]{9}{\hspace{-.5em}$\underbrace{\hspace{9.5em}}_{\text{\small \bus Address}}$}
\end{bytefield}
~
\begin{bytefield}{32}
  \bitheader{0-31} \\
  \bitbox{8}{Address}
  \bitbox{24}{Data}
  \bitbox[lbt]{8}{Address\dots} \\
  \bitbox[t]{40}{$\underbrace{\hspace{42em}}_{\text{\small \bus Data}}$}
\end{bytefield}

Bits~0-23 of the \bus data field are written to the register addressed by
bits~24-31. The write occurs immediately, as soon as the layer controller
receives the message. Multiple registers may be written in a single \bus
transaction by sending multiple data packets. Each 32~bit chunk of data is
treated as if it were an independent transaction.

\paragraph{Overflow:} If more data is received after writing the last register
({\tt 0xff}), the destination address wraps and registers continue to be
written, beginning at address {\tt 0x00}.
{\em Tests: \ref{test:reg-write-overflow}.}
%
\paragraph{Unaligned Access:} The behavior of a message ending on a
non-word boundary is undefined.
%
\paragraph{Interjection Semantics:} Each command is applied immediately when
it is received. A four-command message would have a $4\times32=128$~bit data
payload. If 63~bits are received prior to interjection, only the first command
was applied. If 64~bits are received, the first two commands are applied.
{\em Tests: \ref{test:inj-reg-long}, \ref{test:inj-reg-end}.}

\subsubsection{Register Read}
\label{cmd:register-read}

\begin{bytefield}{9}
  \bitheader{0-7} \\
  \bitbox[rbt]{5}{{\dots}Prefix}
  \bitbox{4}{0001} \\
  \bitbox[t]{9}{\hspace{-.5em}$\underbrace{\hspace{9.5em}}_{\text{\small \bus Address}}$}
\end{bytefield}
~
\begin{bytefield}{32}
  \bitheader{0-31} \\
  \bitbox{8}{Start Address\\to Read From}
  \bitbox{8}{Length-1}
  \bitbox{8}{\bus Address\\to Reply To}
  \bitbox{8}{Address to Write\\on Destination} \\
  \bitbox[t]{32}{$\underbrace{\hspace{33em}}_{\text{\small \bus Data}}$}
\end{bytefield}

Bits~24-31 specify the address of the register to be read. Bits~16-23 may be
used to request that multiple registers are sent. This field is a count of the
number of values to be sent less one, that is a value of~0 requests 1~register
is read and a value of 255 requests that all 256 registers are sent. Bits~8-15
are the \bus address the reply is sent to. Bits~0-7 specify the first address
field of the \nameref{cmd:reg-write} response.

The response message is sent to the \bus address specified in bits~8-15 of the
request and its data field is formatted exactly as the
\nameref{cmd:reg-write} command: 8~bit address + 24~bit data. For reads
of more than one register, the address field in the response is incremented
by~1 for each register.

The response will always respond with the requested number of registers. If a
request for register \#256 would have been made, the request wraps and begins
from register \#0. The destination register address wraps similarly.

\paragraph{Note:} The \bus address to reply to {\bf must} be copied
exactly. The FU\_ID is not required to be \nameref{cmd:reg-write}. For
example, if the FU\_ID is \nameref{cmd:mem-stream-write}, the effect is
dumping the current register state to memory on the target addresss.
{\em Tests: \ref{test:reg-dump-restore}.}

\paragraph{Interjection Semantics:} If the reply is interjected, the
transaction is aborted and is {\bf not} retried.

\subsection{Memory Commands}
\label{cmd:mem}
\proto memory space is a 32~bit addressable array of 32~bit words of memory.
Any undefined accesses are treated as RZWI (Read as Zero, Write Ignored).
\proto provides two types of memory commands: bulk and stream. A bulk memory
transaction is a wholly self-contained event designed for DMA of large blocks
of memory. Memory streams pre-configure the stream destination address and
omit it from subsequent transactions, relying on the receiver to maintain and
increment a destination pointer. Streams are useful for applications such as
continuous sampling, where multiple, short messages are generated.

\subsubsection{Memory Bulk Write}
\label{cmd:mem-bulk-write}

\begin{bytefield}{9}
  \bitheader{0-7} \\
  \bitbox[rbt]{5}{{\dots}Prefix}
  \bitbox{4}{0010} \\
  \bitbox[t]{9}{\hspace{-.5em}$\underbrace{\hspace{9.5em}}_{\text{\small \bus Address}}$}
\end{bytefield}
~
\begin{bytefield}[bitwidth=.4em]{72}
%  \bitheader{0,31} \\
  \bitbox[]{2}{\tiny ~ \\ ~ \\ 31}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ \tt \bf \dots}
  \bitbox[]{26}{}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ 2}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ 1}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ 0}
  \bitbox[]{2}{\tiny ~ \\ ~ \\ 31}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ \tt \bf \dots}
  \bitbox[]{28}{}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ 0}
  \bitbox[]{2}{\tiny ~ \\ ~ \\ 31}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ \tt \bf \dots}
  \\
  \bitbox{30}{DMA Start Address}
  \colorbitbox{lightgray}{1}{\footnotesize \tt Z}
  \colorbitbox{lightgray}{1}{\footnotesize \tt Z}
  \bitbox{32}{Data}
  \bitbox[ltb]{8}{Data\ldots}
  \\
  \bitbox[t]{72}{$\underbrace{\hspace{33em}}_{\text{\small \bus Data}}$}
\end{bytefield}

The first word received is the address in memory to begin writing to. The
bottom two bits of the address field are reserved and {\bf must} be
transmitted as 0. Subsequent words are treated as data. The first word of data
is written to the specified address. The next word of data is written to
address+4 (the next word in memory) and so on. There is no limit on the length
of this message.

\paragraph{Unaligned Access:} The behavior of a message ending on a
non-word boundary is undefined.

\paragraph{Overflow:} If more data is received after writing the last
address in memory ({\tt 0xfffffffc}), the destination address wraps and data
continues to be written, beginning at address {\tt 0x00000000}.
{\em Tests: \ref{test:mem-bulk-overflow}.}

\paragraph{Interjection Semantics:} Each word of data is written to memory
immediately when it is received. A four-word message would have a
$(1+4)\times32=160$~bit data payload. If 95~bits are received prior to
interjection, only the first word was written to memory. If 96~bits are
received, the first two words were written to memory.
{\em Tests: \ref{test:inj-mem-bulk-long}, \ref{test:inj-mem-bulk-end}.}

\subsubsection{Memory Read}
\label{cmd:mem-read}

\begin{bytefield}{9}
  \bitheader{0-7} \\
  \bitbox[rbt]{5}{{\dots}Prefix}
  \bitbox{4}{0011} \\
  \bitbox[t]{9}{\hspace{-.5em}$\underbrace{\hspace{9.5em}}_{\text{\small \bus Address}}$}
\end{bytefield}
~
\begin{bytefield}[bitwidth=.4em]{96}
%  \bitheader{0,31} \\
  \bitbox[]{2}{\tiny ~ \\ ~ \\ 31}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ \tt \bf \dots}
  \bitbox[]{3}{}
  \bitbox[]{2}{\tiny ~ \\ ~ \\ 24}
  \bitbox[]{2}{\tiny ~ \\ ~ \\ 23}
  \bitbox[]{2}{\tiny ~ \\ ~ \\ 20}
  \bitbox[]{2}{\tiny ~ \\ ~ \\ 19}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ \tt \bf \dots}
  \bitbox[]{16}{}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ 0}
  \bitbox[]{2}{\tiny ~ \\ ~ \\ 31}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ \tt \bf \dots}
  \bitbox[]{3}{}
  \bitbox[]{2}{\tiny ~ \\ ~ \\ 24}
  \bitbox[]{2}{\tiny ~ \\ ~ \\ 23}
  \bitbox[]{2}{\tiny ~ \\ ~ \\ 20}
  \bitbox[]{2}{\tiny ~ \\ ~ \\ 19}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ \tt \bf \dots}
  \bitbox[]{14}{}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ 2}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ 1}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ 0}
  \bitbox[]{2}{\tiny ~ \\ ~ \\ 31}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ \tt \bf \dots}
  \bitbox[]{26}{}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ 2}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ 1}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ 0}
  \\
  \bitbox{8}{\tiny \bus Reply Address}
  \colorbitbox{lightgray}{4}{\tiny RS\\VD}
  \bitbox{20}{Length-1}
  \bitbox{30}{Read Start Address}
  \colorbitbox{lightgray}{1}{\footnotesize \tt Z}
  \colorbitbox{lightgray}{1}{\footnotesize \tt Z}
  \colorbitbox{lightred}{30}{DMA Start Address on Destination Node}
  \colorbitbox{lightgray}{1}{\footnotesize \tt Z}
  \colorbitbox{lightgray}{1}{\footnotesize \tt Z}
  \\
  \bitbox[t]{96}{$\underbrace{\hspace{45em}}_{\text{\small \bus Data}}$}
\end{bytefield}

The first word indicates the \bus address to reply to and the length of the
requested read in words less one. A length of~0 will reply with 1~word of
data.
The second word is the address in memory to read from. The bottom two
bits of the address field are reserved and {\bf must} be transmitted as 0.

The third word is {\bf optional}. If the third word is present, it is
prepended to the reply (generating a message with a
\nameref{cmd:mem-bulk-write} formatted payload). If the third word is omitted,
data is immediately placed on the bus (generating a message with a
\nameref{cmd:mem-stream-write} formatted payload).

\paragraph{Overflow:} If the starting address field and subsequent length
exceed the memory space, that is a request for address {\tt 0x100000000} would
have been made during the response, the layer controller wraps and continues
sending from address {\tt 0x00000000}.
{\em Tests: \ref{test:mem-bulk-overflow}.}

\paragraph{Interjection Semantics:} If the reply is interjected, the
transaction is aborted and is {\bf not} retried.

\subsubsection{Memory Stream Write}
\label{cmd:mem-stream-write}

\begin{bytefield}{9}
  \bitheader{0-7} \\
  \bitbox[rbt]{5}{{\dots}Prefix}
  \bitbox{2}{01}
  \colorbitbox{lightcyan}{2}{XX} \\
  \bitbox[t]{9}{\hspace{-.5em}$\underbrace{\hspace{9.5em}}_{\text{\small \bus Address}}$}
\end{bytefield}
~
\begin{bytefield}[bitwidth=.5em]{40}
%  \bitheader{0,31} \\
  \bitbox[]{2}{\tiny ~ \\ ~ \\ 31}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ \tt \bf \dots}
  \bitbox[]{28}{}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ 0}
  \bitbox[]{2}{\tiny ~ \\ ~ \\ 31}
  \bitbox[]{1}{\tiny ~ \\ ~ \\ \tt \bf \dots}
  \\
  \bitbox{32}{Data}
  \bitbox[ltb]{8}{Data\ldots}
  \\
  \bitbox[t]{40}{$\underbrace{\hspace{24em}}_{\text{\small \bus Data}}$}
\end{bytefield}

\proto nodes have up to four streaming memory channels. Each channel is
controlled by configuration registers (\nameref{cmd:conf-memory-stream}). The
destination of a memory stream write is specified by a combination of channel
selection---the last two bits of the FU\_ID---and the pre-arranged
configuration.

The message payload is all data.  The destination address is automatically
incremented every time a word is written.  There is no limit on the length of
this message.

\paragraph{Unaligned Access:} The behavior of a message ending on a
non-word boundary is undefined.

\paragraph{Overflow:} If more data is received after writing the last
address in memory ({\tt 0xfffffffc}), the destination address wraps and data
continues to be written, beginning at address {\tt 0x00000000}.
{\em Tests: \ref{test:mem-stream-overflow}.}

\paragraph{Interjection Semantics:} Each word of data is written to memory
immediately when it is received. A four-word message would have a
$(1+4)\times32=160$~bit data payload. If 95~bits are received prior to
interjection, only the first word was written to memory. If 96~bits are
received, the first two words were written to memory.
{\em Tests: \ref{test:inj-mem-stream-long}, \ref{test:inj-mem-stream-end}.}
